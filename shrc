# shellcheck shell=sh
# -*- coding:utf-8; mode:shell-script; -*-
#
# Copyright 2020 Pradyumna Paranjape
#
# This file is part of Prady_runcom.
#
# Prady_runcom is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Prady_runcom is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with Prady_runcom.  If not, see <https://www.gnu.org/licenses/>.
#
#===================================================================
#  ___             _      ___                     _
# | _ \_ _ __ _ __| |_  _| _ \__ _ _ _ __ _ _ _  (_)_ __  ___
# |  _/ '_/ _` / _` | || |  _/ _` | '_/ _` | ' \ | | '_ \/ -_)
# |_| |_| \__,_\__,_|\_, |_| \__,_|_| \__,_|_||_|/ | .__/\___|
#                    |__/                      |__/|_|
#===================================================================

# shellcheck source=.local/share/pspman/src/runcom/complete.bash
if [ -f "${RUNCOMDIR}"/complete.bash ]; then
    # shellcheck source=.local/share/pspman/src/runcom/complete.bash
    . "${RUNCOMDIR}"/complete.bash
fi

export BEMENU_OPTS='--fn firacode 14 '

python_ver() {
    python --version |cut -d "." -f1,2 |sed 's/ //' |sed 's/P/p/'
}

to_venv () {
    test_d="$(realpath "${PWD}")"
    parents=16  # path too long to waste time
    until mountpoint "${test_d}" > /dev/null 2> /dev/null; do
        if [ $parents -le 0 ]; then
            printf "Too many branch-nodes searched" >&2
            unset parents
            unset test_d
            unset env_d
            return 126
        fi
        for env_d in ".venv" "venv"; do
            if [ -d "${test_d}/${env_d}" ] \
                   || [ -L "${test_d}/${env_d}" ]; then
                # shellcheck disable=SC1090
                . "${test_d}/${env_d}/bin/activate"
                printf "Found %s, switching...\n" "${test_d}/${env_d}"
                unset parents
                unset test_d
                unset env_d
                return 0
            fi
        done
        test_d="$(dirname "${test_d}")"
        parents=$((parents - 1))
    done
    printf "Couldn't find .venv upto mountpoint %s\n" "${test_d}" >&2
    unset parents
    unset test_d
    unset env_d
    return 126
}

_show_venv () {
    # if a virtualenv is active, print it's name
    if [ -n "${VIRTUAL_ENV}" ]; then
        base="$(basename "${VIRTUAL_ENV}")"
        if [ "${base}" = ".venv" ] || [ "${base}" = "venv"  ]; then
            printf "/%s" "$(basename "$(dirname "${VIRTUAL_ENV}")")"
            unset base
        else
            printf "/%s" "${base}"
            unset base
        fi
    fi
}

git_status() {
    modified=0
    cached=0
    untracked=0

    while read -r line; do
        case "${line}" in
            _*_\ _)
                cached=1
                ;;
            _\ _*_)
                modified=1
                ;;
            _?_?_)
                untracked=1
                ;;
        esac
    done << endstat
$(git status --short | cut -b -2 | sed -e 's/\(.\)\(.*\)/_\1_\2_/')
endstat

    stat_str=''
    if [ $modified -ne 0 ]; then
        stat_str="${stat_str}\033[0;31m\ue728"
    fi

    if [ $cached -ne 0 ]; then
        stat_str="${stat_str}\033[0;32m\ue729"
    fi

    if [ $untracked -ne 0 ]; then
        stat_str="${stat_str}\033[0;31m\uf476"
    fi

    if [ -n "$(git stash list)" ]; then
        stat_str="${stat_str}\e[0;36m\uf48e"
    fi
    if [ -n "${stat_str}" ]; then
        # shellcheck disable=SC2059  # I do want escape characters
        printf "${stat_str}\e[m"
    fi
    unset modified
    unset cached
    unset untracked
}

#!/usr/bin/env sh
# -*- coding: utf-8; mode: shell-script; -*-


git_branch() {
    branch_str=''
    branch="$(git branch 2>/dev/null | grep '^\*' | sed -e 's/^* //')"
    if [ -n "${branch}" ]; then
        case "${branch}" in
            feat-*)
                branch_str="${branch_str}\033[0;32m"
                ;;
            bug-*)
                branch_str="${branch_str}\033[0;31m"
                ;;
            act-*)
                branch_str="${branch_str}\e[0;36m"
                ;;
            tmp-*)
                branch_str="${branch_str}\e[0;36m"
                ;;
            *HEAD\ detached*)
                branch_str="${branch_str}\e[0;33m"
                ;;
            master)
                unset branch
                unset branch_str
                return
                ;;
            *)
                branch_str="${branch_str}\e[0;35m"
                ;;
        esac
    fi
    printf "${branch_str}%s\ue725\e[m" "${branch}"
    unset branch_str
    unset branch
}

git_hash() {
    git log --pretty=format:'%h' -n 1
}

git_ps() {
    if ! git status --ignore-submodules >/dev/null 2>&1; then
        return
    else
        printf " %s%s%s " "$(git_branch)" "$(git_hash)" "$(git_status)"
    fi
}

last_exit_color () {
    err="$1"
    if [ "$err"  = "0" ]; then
        # no error
        printf "\e[0;32m"
    elif [ "$err"  = "1" ]; then
        # general error
        printf "\e[0;33m"
    elif [ "$err"  = "2" ]; then
        # misuse of shell builtins
        printf "\e[0;31m"
    elif [ "$err" -gt "63" ] && [ "$err" -lt "84" ]; then
        # syserror.h
        printf "\e[0;91m"
    elif [ "$err"  = "126" ]; then
        # cannot execute
        printf "\e[0;37m"
    elif [ "$err"  = "127" ]; then
        # command not found
        printf "\e[0;30m"
    elif [ "$err" -gt "127" ] && [ "$err" -lt "191" ]; then
        # Fatal error
        printf "\e[0;41m"
    elif [ "$err"  = "255" ]; then
        # exit status limit
        printf "\e[0;31m"
    else
        printf "\e[0;31m"
    fi
    unset err
}

mathcalc() {
    echo "$*"| bc -lq
}

dec2hex() {
    echo "hex:"
    echo "obase=16; $*"| bc
    echo "dec:"
    echo "ibase=16; $*"| bc
}

pdfcompile() {
    pdflatex "$1"
    for ext in ".toc" ".log" ".aux"; do
        [ -f "${1%.tex}${ext}" ] && rm "${1%.tex}${ext}"
    done
    evince "${1%.tex}.pdf"
}

org2export() {
    # Usage: org2oth [-f] <infile> <othtype>
    proceed=
    while test $# -gt 1; do
        case "$1" in
            -f|--force)
                proceed=true
                shift 1
                ;;
            *)
                infile="${1}"
                shift 1
                ;;
        esac
    done
    if [ "${1}" = "pdf" ]; then
        target="latex"
    else
        target="${1}"
    fi
    case "$infile" in
        *.org)
            proceed=true
            ;;
        *)
            echo "Input file should be an org file"
            ;;
    esac
    if [ -n "$proceed" ]; then
        pandoc -f org -t "${target}" -o "${infile%.*}.${1}" "$infile"
    fi
    unset proceed
    unset target
    unset infile
}

org2doc () {
    org2export "$@" "docx"
}

org2pdf () {
    org2export "$@" "pdf"
}

doc2org() {
    case "${1}" in
        *.docx)
            pandoc -f docx -t org -o "${1%.docx}.org" "$1"
            ;;
        *)
            echo "Input file must be a docx file"
            ;;
    esac
}

mount_home_cloud() {
    # shellcheck disable=SC2154
    if [ -z "${home_cloud}" ] || [ -z "${cloud_user}" ]; then
        echo "variables \$home_cloud OR \$cloud_user haven't been defined"
        return
    fi
    # netcheck source=./netcheck.sh
    IFS="$(printf '\t')" read -r IP_ADDR AP_ADDR netstate << netcheck
$("${RUNCOMDIR}"/netcheck.sh)
netcheck
    if [ $(( netstate % 4 )) -eq 2 ]; then
        srv_mnt_dir="${HOME}/${home_cloud}"

        set -- "/media/data" "/home/${cloud_user}"
        if [ "$(mount | grep -c "${srv_mnt_dir}")" -lt "$#" ]; then
            # not mounted
            while [ $# -gt 0 ]; do
                mkdir -p "${srv_mnt_dir}${1}"
                sshfs -o \
                      "reconnect,ServerAliveInterval=15,ServerAliveCountMax=3" \
                      "${cloud_user}@${home_cloud}:${1}" "${srv_mnt_dir}${1}"
                shift
            done
        fi
    fi
    unset srv_mnt_dir
}

gui () {
    usage="usage: $0 [-h|--help] CMD\n"
    cmd_help="Launch CMD, switch to it, and exit the parent terminal\n\n"
    cmd_help="${cmd_help}Optional arguments:\n"
    cmd_help="${cmd_help}-h|--help\tdisplay this help and exit\n"
    command=
    call=

    while [ $# -gt 0 ]; do
        case "$1" in
            --help|-h)
                printf "%s""${usage}"
                printf "%s""${cmd_help}"
                shift 1
                unset command
                unset cmd_help
                unset usage
                unset call
                return 0
                ;;
            --)
                # end of gui arguments
                command="${command} $*"
                break
                ;;
            *)
                command="${1}"
                shift 1
                ;;
        esac
    done

    call="$(echo "${command}" | cut -d " " -f 1)"
    if [ -n "${call}" ]; then
        if command -v "${call}" >/dev/null 2>&1; then
            unset cmd_help
            unset usage
            unset call
            nohup "${command}" >/dev/null 0<&- 2>&1 & exit 0
        else
            echo "${call} not found..."
            unset command
            unset cmd_help
            unset usage
            unset call
            return 127
        fi
    else
        printf "%s""${usage}"
        unset command
        unset cmd_help
        unset usage
        unset call
        return 1
    fi

}

deconvolute() {
    if [ ! -f "$1" ]; then
        echo "$1: no such file";
    else
        case "$1" in
            *.tar.bz2) tar -xjf "$1" ;;
            *.tbz2) tar -xjf "$1" ;;
            *.tar.gz) tar -x --use-compress-program=pigz -f "$1" ;;
            *.tgz) tar -x --use-compress-program=pigz -f "$1" ;;
            *.gz) pigz "$1" ;;
            *.rar) unrar -x "$1" ;;
            *.tar) tar -xf "$1" ;;
            *.zip) unzip "$1" ;;
            *.tar.xz) tar -xf "$1" ;;
            *) echo "Cannot extract $1, provide explicit command";;
        esac
    fi
}

cd () {
    builtin cd "$1"
    if [ -z "${VIRTUAL_ENV}" ]; then
        to_venv 2>/dev/null
    fi
}

force_global_venv () {
    if [ "${VIRTUAL_ENV}" = "Global_Env" ]; then
        unset VIRTUAL_ENV
        to_venv 2>/dev/null
    else
        deactivate
        VIRTUAL_ENV="Global_Env"
    fi
}

lfcd () {
    if ! command -v 'lf' >/dev/null 2>/dev/null; then
        return
    fi
    tmp_file="$(mktemp)"
    lf -last-dir-path="${tmp_file}" "$@"
    if [ -f "${tmp_file}" ]; then
        target_dir="$(cat "${tmp_file}")"
        rm -f "${tmp_file}" >/dev/null
        if [ -d "${target_dir}" ] && [ "${target_dir}" != "$(pwd)" ]; then
            cd "${target_dir}" || return
        fi
    fi
    unset tmp_file
    unset target_dir
}
fzfcd () {
    cd "$(dirname "$(fzf)")" || true
}

alias du='du -hc';
alias df='df -h';
alias duall="du -hc |\grep '^[3-9]\{3\}M\|^[0-9]\{0,3\}\.\{0,1\}[0-9]\{0,1\}G'";

alias nload='nload -u M -U G -t 10000 -a 3600 $(ip a | grep -m 1 " UP " | cut -d " " -f 2 | cut -d ":" -f 1)'
alias nethogs='\su - -c "nethogs $(ip a |grep  "state UP" | cut -d " " -f 2 | cut -d ":" -f 1) -d 10"';
alias ping="ping -c 4 ";

alias watch="watch -n 10 --color";

alias qqqq="exit";

if command -v 'bat' >/dev/null 2>&1; then
    alias cat="bat --color=auto";
fi

for sc in "ack" "pt" "ag" "rg"; do
    if command -v "${sc%% *}" >/dev/null 2>&1; then
        # shellcheck disable=SC2139
        alias grep="${sc} --color=auto";
    fi
done

if command -v "exa" >/dev/null 2>&1; then
    alias ls="exa -Fh --color=auto";
    alias la='exa -a --color=auto';
    alias ll='exa -lr -s size';
    alias lla='exa -a';
    alias l.='exa -a --color=auto |grep "^\."';
    alias sl="ls";
fi

if command -v nvim >/dev/null 2>&1; then
    alias ex="nvim"; # always open vim in normal mode
    alias vim="nvim"; # always use neo
fi

if command -v podman >/dev/null 2>&1; then
    alias docker="podman";  # Podman is drop-in replacement for docker
    alias docker-compose="podman-compose";  # Podman is drop-in replacement for docker
fi

# shellcheck source=./netcheck.sh
IFS="$(printf '\t')" read -r IP_ADDR AP_ADDR netstate << netcheck
$("${RUNCOMDIR}"/netcheck.sh)
netcheck
export IP_ADDR
export AP_ADDR
if [ "${netstate}" -gt 7 ]; then
    printf "\e[1;34mInternet (GOOGLE) Connected\e[m\n"
    printf "\033[0;32m%s \e[m is current wireless ip address\n" "$IP_ADDR"
else
    printf "\e[1;31mInternet (GOOGLE) Not reachable\e[m\n"
    if [ $(( netstate % 8 )) -gt 3 ]; then  # Intranet is connected
        printf "\033[0;31mInternet Down\e[m\n"
        case $(( netstate % 4 )) in
            2) printf "Home network connected,\n"
               ;;
            1) printf "OFFICE network connected,\n"
               # shellcheck source=./proxy_send.py
               if [ -f "${RUNCOMDIR}/proxy_send.py" ]; then
                   # shellcheck source=./proxy_send.py
                   "${RUNCOMDIR}/proxy_send.py" \
                       && printf "\e[0;33mPROXY AUTH SENT\e[m\n";
               fi
               ;;
            *) printf "HOTSPOT connected\n"
               ;;
        esac
    else
        printf "\e[1;33mNetwork connection Disconnected\e[m\n"
    fi
fi
