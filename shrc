# shellcheck shell=sh

# -*- coding:utf-8; mode:shell-script; -*-
#
# Copyright 2020, 2021 Pradyumna Paranjape
#
# This file is part of Prady_runcom.
#
# Prady_runcom is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Prady_runcom is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with Prady_runcom.  If not, see <https://www.gnu.org/licenses/>.
#
#===================================================================
#  ___             _      ___                     _
# | _ \_ _ __ _ __| |_  _| _ \__ _ _ _ __ _ _ _  (_)_ __  ___
# |  _/ '_/ _` / _` | || |  _/ _` | '_/ _` | ' \ | | '_ \/ -_)
# |_| |_| \__,_\__,_|\_, |_| \__,_|_| \__,_|_||_|/ | .__/\___|
#                    |__/                      |__/|_|
#===================================================================

# shellcheck disable=SC1090
for unsync_d in local.d pvt.d; do
    for rcfile in "${XDG_CONFIG_HOME:-${HOME}/.config}/${unsync_d}"/.*rc; do
        . "${rcfile}"
    done 2>/dev/null
done 2>/dev/null

unset rcfile
unset unsync_d

if builtin command -v 'bat' >/dev/null 2>&1; then
    alias cat="bat --color=auto";
fi

for sc in "ack" "pt" "ag" "rg"; do
    if builtin command -v "${sc%% *}" >/dev/null 2>&1; then
        # shellcheck disable=SC2139
        alias grep="${sc} --color=auto";
    fi
done

if builtin command -v "exa" >/dev/null 2>&1; then
    alias ls="exa -Fh --color=auto";
    alias la='exa -a --color=auto';
    alias ll='exa -lr -s size';
    alias lla='exa -a';
    alias l.='exa -a --color=auto |grep "^\."';
    alias sl="ls";
fi

if builtin command -v nvim >/dev/null 2>&1; then
    alias ex="nvim"; # always open vim in normal mode
    alias vim="nvim"; # always use neo
fi

if builtin command -v podman >/dev/null 2>&1; then
    alias docker="podman";  # Podman is drop-in replacement for docker
    alias docker-compose="podman-compose";  # Podman is drop-in replacement for docker
fi

export BEMENU_OPTS='--fn firacode 14 '

python_ver() {
    python --version |cut -d "." -f1,2 |sed 's/ //' |sed 's/P/p/'
}

to_venv () {
    test_d="$(realpath "${PWD}")"
    parents=16  # path too long to waste time
    until mountpoint "${test_d}" > /dev/null 2> /dev/null; do
        if [ $parents -le 0 ]; then
            printf "Too many branch-nodes searched" >&2
            unset parents
            unset test_d
            unset env_d
            return 126
        fi
        for env_d in ".venv" "venv"; do
            if [ -d "${test_d}/${env_d}" ] \
                   || [ -L "${test_d}/${env_d}" ]; then
                # shellcheck disable=SC1090
                . "${test_d}/${env_d}/bin/activate"
                printf "Found %s, switching...\n" "${test_d}/${env_d}"
                unset parents
                unset test_d
                unset env_d
                return 0
            fi
        done
        test_d="$(dirname "${test_d}")"
        parents=$((parents - 1))
    done
    printf "Couldn't find .venv upto mountpoint %s\n" "${test_d}" >&2
    unset parents
    unset test_d
    unset env_d
    return 126
}

_show_venv () {
    # if a virtualenv is active, print it's name
    if [ -n "${VIRTUAL_ENV}" ]; then
        base="$(basename "${VIRTUAL_ENV}")"
        if [ "${base}" = ".venv" ] || [ "${base}" = "venv"  ]; then
            printf "/%s" "$(basename "$(dirname "${VIRTUAL_ENV}")")"
            unset base
        else
            printf "/%s" "${base}"
            unset base
        fi
    fi
}

git_status() {
    _modified=0
    _cached=0
    _untracked=0

    while read -r _line; do
        case "${_line}" in
            _*_\ _)
                _cached=1
                ;;
            _\ _*_)
                _modified=1
                ;;
            _?_?_)
                _untracked=1
                ;;
        esac
    done << endstat
$(git status --short | cut -b -2 | sed -e 's/\(.\)\(.*\)/_\1_\2_/')
endstat

    _stat_str=''
    if [ "$_modified" -ne 0 ]; then
        _stat_str="${_stat_str}\033[0;31m\ue728"
    fi

    if [ "$_cached" -ne 0 ]; then
        _stat_str="${_stat_str}\033[0;32m\ue729"
    fi

    if [ "$_untracked" -ne 0 ]; then
        _stat_str="${_stat_str}\033[0;31m\uf476"
    fi

    if [ -n "$(git stash list)" ]; then
        _stat_str="${_stat_str}\e[0;36m\uf48e"
    fi
    if [ -n "${_stat_str}" ]; then
        # shellcheck disable=SC2059  # I do want escape characters
        printf "${_stat_str}\e[m"
    fi
    unset _modified
    unset _cached
    unset _untracked
    unset _stat_str
}

git_branch() {
    branch_str=''
    branch="$(git branch 2>/dev/null | grep '^\*' | sed -e 's/^* //')"
    if [ -n "${branch}" ]; then
        case "${branch}" in
            feat-*)
                branch_str="${branch_str}\033[0;32m"
                ;;
            bug-*)
                branch_str="${branch_str}\033[0;31m"
                ;;
            act-*)
                branch_str="${branch_str}\e[0;36m"
                ;;
            tmp-*)
                branch_str="${branch_str}\e[0;36m"
                ;;
            *HEAD\ detached*|,*rebasing*)
                branch_str="${branch_str}\e[0;33m"
                ;;
            main|master)
                unset branch
                unset branch_str
                return
                ;;
            *)
                branch_str="${branch_str}\e[0;35m"
                ;;
        esac
    fi
    printf "${branch_str}%s\ue725\e[m" "${branch}"
    unset branch_str
    unset branch
}

git_hash() {
    git log --pretty=format:'%h' -n 1
}

git_ps() {
    if ! git status --ignore-submodules >/dev/null 2>&1; then
        return
    else
        printf " %s%s%s " "$(git_branch)" "$(git_hash)" "$(git_status)"
    fi
}

last_exit_color () {
    case "$1" in
        0)
            # success
            printf "\e[0;32m"
            ;;
        1)
            # general error
            printf "\e[0;33m"
            ;;
        2)
            # misuse of shell builtins
            printf "\e[0;31m"
            ;;
        126)
            # cannot execute
            printf "\e[0;37m"
            ;;
        127)
            # command not found
            printf "\e[0;30m"
            ;;
        255)
            # exit status limit
            printf "\e[0;31m"
            ;;
        *)
            if [ "$1" -gt "63" ] && [ "$1" -lt "84" ]; then
                # syserror.h
                printf "\e[0;91m"

            elif [ "$1" -gt "127" ] && [ "$1" -lt "191" ]; then
                # Fatal error
                printf "\e[0;41m"
            else
                printf "\e[0;31m"
            fi
            unset _err
            ;;
    esac
}

_elapsed_time() {
    # $1 is start time $2 is end time
    _cmd_start="$1"
    _cmd_end="$2"
    if [ -z "$_cmd_end" ] || [ -z "$_cmd_start" ]; then
        return
    fi
    _sec=$(( _cmd_end - _cmd_start ))
    unset _cmd_start
    unset _cmd_end
    if [ "$_sec" -le 0 ]; then
        return
    fi
    if [ "$_sec" -le 60 ]; then
        printf "%s" "${_sec}"
        unset _sec
        return
    fi
    _min=$(( _sec/60 ))
    unset _sec
    if [ "$_min" -le 60 ]; then
        printf "%sm" "${_min}"
        unset _min
        return
    fi
    _hr=$(( _min/60 ))
    unset _min
    if [ "$_hr" -le 24 ]; then
        printf "%sh" "${_hr}"
        unset _hr
        return
    fi
    _day=$(( _hr/24 ))
    unset _min
    printf "%sd" "${_day}"
    unset _day
}

mathcalc() {
    echo "$*"| bc -lq
}

dec2hex() {
    echo "hex:"
    echo "obase=16; $*"| bc
    echo "dec:"
    echo "ibase=16; $*"| bc
}

pdfcompile() {
    if ! builtin command -v "pdflatex" 1>/dev/null 2>&1; then
        printf "pdftex is not installed\n"
        return 127
    fi

    pdflatex "$1"
    for ext in ".toc" ".log" ".aux"; do
        [ -f "${1%.tex}${ext}" ] && rm "${1%.tex}${ext}"
    done
    if builtin command -v "pdflatex" 1>/dev/null 2>&1; then
        zathura "${1%.tex}.pdf"
    fi
}

org2export() {
    # Usage: org2oth [-f] <infile> <othtype>
    if ! builtin command -v "pandoc" 1>/dev/null 2>&1; then
        printf "pandoc is not installed\n"
        return 127
    fi
    proceed=false
    while test $# -gt 1; do
        case "$1" in
            -f|--force)
                proceed=true
                shift 1
                ;;
            -h|--help)
                printf "Usage: org2export [-h|--help] [-f|--force] FILENAME.org OUTFMT\n\n"
                printf "Optional Arguments:\n"
                printf "%s\tshow this help message\n\n" "-h|--help"
                printf "%s\tignore extension mismatch\n" "-f|--force"
                printf "Positional Arguments:\n"
                printf "FILENAME.org\tpath to input filename\n"
                printf "OUTFMT\t\tformat of output [pdf, docs, ...]\n"
                return 0
                ;;
            --)
                shift 1
                ;;
            *)
                infile="${1}";
                target="${2}";
                break
                ;;
        esac
    done
    if [ "${target}" = "pdf" ]; then
        target="latex"
    fi
    if [ "${infile%.org}" = "${infile}" ]; then
        # <infile>
        printf "Input file should be an org file\n"
    else
        # <infile>.org
        proceed=true
    fi
    if $proceed; then
        pandoc -f org -t "${target}" -o "${infile%.*}.${1}" "$infile"
    fi
    unset proceed
    unset target
    unset infile
}

org2doc () {
    org2export "$@" "docx"
}

org2pdf () {
    org2export "$@" "pdf"
}

doc2org() {
    if ! builtin command -v "pandoc" 1>/dev/null 2>&1; then
        printf "pandoc is not installed\n"
        return 127
    fi

    case "${1}" in
        *.docx)
            pandoc -f docx -t org -o "${1%.docx}.org" "$1"
            ;;
        *)
            echo "Input file must be a docx file"
            ;;
    esac
}

mount_cloud_sshfs() {
    mount_script="${RUNCOMDIR:-${HOME}/.runcom}/bin/cloud_mount.sh"
    if [ -f "${mount_script}" ]; then
        eval "${mount_script}"
    fi
}

umount_cloud_sshfs() {
    mount_script="${RUNCOMDIR:-${HOME}/.runcom}/bin/cloud_mount.sh"
    if [ -f "${mount_script}" ]; then
        eval "${mount_script}" "umount"
    fi
}

gui () {
    "${RUNCOM:-${HOME}/.runcom}/bin/gui.sh" "$*"
    if [ $? = 65 ]; then
        # if bin/gui.sh returns 65, kill shell, else, maintain
        exit 0
    fi
}

deconvolute() {
    if builtin command -v "pigz"; then
        _gzip="pigz"
    else
        _gzip='gzip'
    fi
    if [ ! -f "${1}" ]; then
        echo "${1}: no such file";
    else
        case "${1}" in
            *.tar.bz2) tar -xjf "${1}" ;;
            *.tbz2) tar -xjf "${1}" ;;
            *.tar.gz) tar -x --use-compress-program="${_gzip}" -f "${1}" ;;
            *.tgz) tar -x --use-compress-program="${_gzip}" -f "${1}" ;;
            *.gz) unpigz "${1}" || gunzip "${1}" ;;
            *.rar) unrar -x "${1}" ;;
            *.tar) tar -xf "${1}" ;;
            *.zip) unzip "${1}" ;;
            *.tar.xz) tar -xf "${1}" ;;
            *) echo "Cannot extract ${1}, provide explicit command";;
        esac
    fi
    unset _gzip
}

cd () {
    if [ -z "${1}" ]; then
        builtin cd "${HOME}" || true
    else
        builtin cd "${1}"  || true
    fi
    if [ -z "${VIRTUAL_ENV}" ]; then
        to_venv 2>/dev/null
    fi
}

lfcd () {
    if ! command -v 'lf' >/dev/null 2>/dev/null; then
        printf "lf is not installed\n"
        return 127
    fi
    tmp_file="$(mktemp)"
    lf -last-dir-path="${tmp_file}" "$@"
    if [ -f "${tmp_file}" ]; then
        target_dir="$(cat "${tmp_file}")"
        rm -f "${tmp_file}" >/dev/null
        if [ -d "${target_dir}" ] && [ "${target_dir}" != "$(pwd)" ]; then
            cd "${target_dir}" || return
        fi
    fi
    unset tmp_file
    unset target_dir
}

fzfcd () {
    if ! command -v 'fzf' >/dev/null 2>/dev/null; then
        printf "fzf is not installed\n"
        return 127
    fi
    cd "$(dirname "$(fzf)")" || true
}

zwc () {
    args="$*"
    fname="${args##* }"
    args="${args% ${fname}}"
    args="${args%${fname}}"

    if gzip -t "${fname}" > /dev/null 2>&1; then
        if [ -z "${args}" ]; then
            zcat -f "${fname}" | wc
        else
            # shellcheck disable=SC2086
            zcat -f "${fname}" | wc $args
        fi
        return
    else
        wc "$@"
        return
    fi

}

force_global_venv () {
    if [ "${VIRTUAL_ENV}" = "Global_Env" ]; then
        unset VIRTUAL_ENV
        to_venv 2>/dev/null
    else
        deactivate 2>/dev/null
        VIRTUAL_ENV="Global_Env"
    fi
}

lszcat () {
    args="$*"
    fname="${args##* }"
    args="${args%% ${fname}}"
    args="${args%%${fname}}"

    if builtin command -v bat >/dev/null 2>&1; then
        betcat="$(which bat)"
    else
        betcat="$(which cat)"
    fi

    if builtin command -v exa >/dev/null 2>&1; then
        betls="$(which exa)"
    else
        betls="$(which ls)"
    fi

    if [ -z "${fname}" ] || [ ! "${fname#-}" = "${fname}" ]; then
        if [ -z "${args}" ]; then
            args="${fname}"
        else
            args="${args} ${fname}"
        fi
        fname="$(readlink -f ".")"
        echo "${fname}"
    fi

    if [ -d "${fname}" ]; then
        # shellcheck disable=SC2086
        "${betls}" ${args} "${fname}"
    elif gzip -t "${fname}" >/dev/null 2>&1; then
        # shellcheck disable=SC2086
        zcat -f ${args} "${fname}" | "${betcat}"
    else
        # shellcheck disable=SC2086
        "${betcat}" ${args} "${fname}"
    fi
}

man_help () {
    if man "$@"; then
        return 0
    elif tldr "$@"; then
        return 0
    elif builtin command -v "$1" >/dev/null 2>/dev/null; then
        printf "trying to display %s --help output\n" "${1}"
        if builtin command -v 'bat' >/dev/null 2>/dev/null; then
            $1 --help 2>&1 | bat
        else
            $1 --help 2>&1 | less -RF
        fi
        return 0
    else
        return 16
    fi
}

alias du='du -hc';
alias df='df -h';
alias duall="du -hc |\grep '^[3-9]\{3\}M\|^[0-9]\{0,3\}\.\{0,1\}[0-9]\{0,1\}G'";

alias man="man_help";

alias nload='nload -u M -U G -t 10000 -a 3600 $(ip a | grep -m 1 " UP " | cut -d " " -f 2 | cut -d ":" -f 1)'
alias nethogs='\su - -c "nethogs $(ip a | grep  "state UP" | cut -d " " -f 2 | cut -d ":" -f 1) -d 10"';
alias ping="ping -c 4 ";

alias watch="watch -n 10 --color";

alias qqqq="exit";

alias wc="zwc";

# shellcheck source=./bin/netcheck.sh
o_ifs="${IFS}"
IFS="$(printf "\t")" read -r ip_addr _ netstate << netcheck
$("${RUNCOMDIR:-${HOME}/.runcom}"/bin/netcheck.sh)
netcheck
IFS="${o_ifs}"
if [ $(( netstate & 8)) = 8 ]; then
    printf "\e[1;34mInternet (GOOGLE) Connected\e[m\n"
    if [ ! $(( netstate & 16))  = 16 ]; then
        printf "\e[1;35mProblem with DNS\e[m\n"
    fi
    printf "\033[0;32m%s \e[m is current wireless ip address\n" "$ip_addr"
else
    printf "\e[1;31mInternet (GOOGLE) Not reachable\e[m\n"
    if [ $(( netstate & 4 )) = 4 ]; then  # Intranet is connected
        printf "\033[0;31mInternet Down\e[m\n"
        if [ $(( netstate & 2 )) = 2 ]; then
            printf "Home network connected,\n"
        elif [ $(( netstate & 1 )) = 1 ]; then
            printf "OFFICE network connected,\n"
            # shellcheck source=./bin/proxy_send.sh
            auto_proxy="${RUNCOMDIR:-${HOME}/.runcom}/bin/proxy_send.sh"
            if [ -f "${auto_proxy}" ]; then
                # shellcheck source=./proxy_send.py
                eval "$auto_proxy" && printf "\e[0;33mPROXY AUTH SENT\e[m\n";
            fi
            unset auto_proxy
        else
            printf "HOTSPOT connected\n"
        fi
    else
        printf "\e[1;33mNetwork connection Disconnected\e[m\n"
    fi
fi
unset o_ifs
unset ip_addr
