# -*- mode:org; coding: utf-8; -*-
#+TITLE: Prady_runcom
#+AUTHOR: Pradyumna Paranjape
#+EMAIL: pradyparanjpe@rediffmail.com
#+LANGUAGE: en
#+OPTIONS: toc:2 num:nil html-postamble:nil ^:nil mathjax:t TeX:t ::t tags:nil *:t skip:t ^:nil
#+STARTUP: overview
#+PROPERTY: header-args :tangle yes
#+SETUPFILE: https://fniessen.github.io/org-html-themes/org/theme-readtheorg.setup
#+EXPORT_FILE_NAME: docs/index.html

* Prady_runcom
** What's this?
   - A compilation of dotfiles: default variables, custom functions.
   - *My* configuration backup, "[[https://git-scm.com/docs/git-push][push]]"ed to work as a template for yours.


*** Aim
    - Cross-machine synchronization (hence, git)
    - Modularity (hence, not a single file)
    - Self-documenting (hence, a single ðŸ˜‰ org file)
    - Workflow speed (obviously)
    - "Pretty" low resource load (hence, not GNOME/KDE)

*** Non-aim
    - Ease

** Will you be able to set this up?
   Probably [[*Knowledge][*NOT*]].
   #+begin_important
   Read till the end before you decide to set this up.
   #+end_important

* Copyright/License Header
  Copyright 2020, 2021 Pradyumna Paranjape

  This file is part of Prady_runcom.

  Prady_runcom is free software: you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.

  Prady_runcom is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with Prady_runcom.  If not, see <https://www.gnu.org/licenses/>.

* Legend
** Brackets
   - *Square* =[]=: optional parts: =W[orld]H[ealth]O[rganisation]=
   - *Angular* =<>=: instructions to fill: =<a global organisation>=
   - *Curly*, following a dollar =${}=: environment variable =${HOME}=
   - *Round*, with bar separator: =(WHO|UNO)= = /WHO or UNO/

* Requirements
** Knowledge
   - Linux shell commands. We shall try to be POSIX-compliant.
   - Knowledge of Linux, "dotfiles".
   - super user (sudo) permissions (only for package installation)
     #+begin_warning
     Avoid use of *sudo* as much as possible.
     #+end_warning

** Dependencies
   - A GNU/Linux distribution. I use [[https://fedoraproject.org][Fedora]].
   - [[https://curl.se/][curl]] for proxy authentication.
   - GNU [[https://www.gnu.org/software/stow/][stow]]: dotfile management
   - [[https://git-scm.com/][git]]: git it

   #+begin_important
   For Alpine Linux, [[/etc/apk/repositories][enable]] the [[https://<mirror-server>/alpine/<version>/community][community repository]].
   - If you are using Alpine, you *MUST* know how.
   #+end_important

*** Bootstrap installation of dependencies

    For automated setup, run the [[./setup/dependencies.sh][dependencies script]] with elevated privileges.
    #+BEGIN_SRC sh :tangle no
      curl -sLf "https://pradyparanjpe.github.io/runcom/setup/dependencies.sh" | sudo sh
    #+END_SRC

    #+begin_note
    Inspecting scripts before running them (especially with =sudo=) is always a good idea.
    The /dependencies/ script is tangled (with automation wrappers) from the code below.
    If you feel an urge to inspect it or if it fails,
    install dependencies manually instead, that's all it does.
    #+end_note

*** Guide for manual installation of dependencies.
    Use suitable package manager to install curl, git, stow.
    It may be useful to update existing packages and repository database before installing packages.

    #+BEGIN_SRC sh :tangle setup/dependencies.sh :exports none
      #!/usr/bin/env sh
      # -*- coding: utf-8; mode: shell-script; -*-
      dnf_install() {
    #+end_src

    - dnf: Fedora, RockyLinux, RHEL, CentOS
      #+BEGIN_SRC sh :tangle setup/dependencies.sh
        dnf -y update || return 65
        dnf -y install curl git stow || return 66
      #+end_src

      #+BEGIN_SRC sh :tangle setup/dependencies.sh :exports none
        }

         apk_install() {
      #+end_src

    - apk: Alpine Linux
      #+begin_src sh :tangle setup/dependencies.sh
        apk update || return 65
        apk --virtual runcom add curl git stow || return 66
      #+end_src

      #+BEGIN_SRC sh :tangle setup/dependencies.sh :exports none
        }

         apt_install() {
      #+end_src

    - apt: Debian, Ubuntu
      #+begin_src sh :tangle setup/dependencies.sh
        apt update || return 65
        apt install -y curl git stow || return 66
      #+end_src

      #+BEGIN_SRC sh :tangle setup/dependencies.sh :exports none
        }

         zypper_install() {
      #+end_src

    - zypper: OpenSuSE, SuSE
      #+begin_src sh :tangle setup/dependencies.sh
        zypper ref || return 65
        zypper -n install curl git stow || return 66
      #+end_src

      #+BEGIN_SRC sh :tangle setup/dependencies.sh :exports none
        }

         pacman_install() {
      #+end_src

    - pacman: Arch, Manjaro
      #+begin_src sh :tangle setup/dependencies.sh
        pacman --noconfirm -Syu curl git stow || return 65
      #+end_src

    #+begin_src sh :tangle setup/dependencies.sh :exports none
      }
       guess_manager() {
           for manager in dnf apt apk zypper pacman; do
               if command -v "${manager}" 1>/dev/null 2>&1; then
                   printf "${manager}"
                   return 0
               fi
           done
           printf ""
           return 127
       }

       install_dep () {
           if [ -z "$1" ]; then
               manager="$(guess_manager)"
               if [ -z "${manager}" ]; then
                   return 127
               fi
           else
               manager="${1}"
           fi
           eval "${manager}_install"
       }

       main() {
           install_dep "$@"
           case $? in
               0)
                   printf "Dependencies installation complete\n"
                   printf "Proceed to setup\n"
                   ;;
               65)
                   printf "Manager is available, but update threw error\n"
                   printf "Please install dependencies manually\n"
                   printf "aborting...\n"
                   return 1;
                   ;;
               66)
                   printf "Manager is available, but package installation threw error\n"
                   printf "Please install dependencies manually\n"
                   printf "aborting...\n"
                   return 1;
                   ;;
               127)
                   printf "Couldn't guess package manger\n"
                   printf "Please install dependencies manually\n"
                   printf "aborting...\n"
                   return 127;
                   ;;
               ,*) printf "Error number %s was thrown by the package manager\n" "$?"
                  printf "Please install dependencies manually\n"
                  printf "aborting...\n"
                  ;;
           esac
       }

       main "$@"
    #+END_SRC

* Setup
  - Affirm [[*Requirements][requirements]].
  #+begin_warning
  Do *NOT* use =sudo= during setup.
  #+end_warning

  #+begin_warning
  - The next steps require you to delete all [[*Structure][stowed dotfiles]].
  - We shall copy them in a directory named =${HOME}/OLD_CONFIG= before proceeding.
  - Preserve this backup, you will need this during un-setup.
  - You HAVE BEEN warned.
  #+end_warning

** Bootstrap setup using script
   - Setup may be bootstrapped by running the [[./setup/setup.sh][setup]] script.

     #+BEGIN_SRC sh :tangle no
       curl -sLf "https://pradyparanjpe.github.io/runcom/setup/setup.sh" | sudo sh

     #+END_SRC

     #+begin_note
     Inspecting scripts before running them is generally a good idea.
     The /setup/ script is tangled (with automation wrappers) from the code below.
     If you feel an urge to inspect it or if it fails,
     follow manual setup instructions with modifications instead.
     #+end_note

** Guide for manual setup.

   #+BEGIN_SRC sh :tangle setup/setup.sh :exports none
     #!/usr/bin/env sh
     # -*- coding: utf-8; mode: shell-script; -*-
   #+end_src

*** Clone the repository and place at =${HOME}/.runcom=

    #+BEGIN_SRC sh :tangle setup/setup.sh :exports none
      clone_repo () {
          if [ ! -d "${HOME}/.runcom" ]; then
    #+END_SRC

    #+BEGIN_SRC sh :tangle setup/setup.sh
      git clone --recurse-submodules "https://github.com/pradyparanjpe/runcom" "${HOME}/.runcom" || exit 1
    #+END_SRC

    #+BEGIN_SRC sh :tangle setup/setup.sh :exports none
      else
          printf "${HOME}/.runcom already exists. Quitting...\n"
          exit 0
      fi
      }

       mask_stow_directories() {
    #+END_SRC

*** Stow dotfiles
    - =GNU stow= will create symlinked structure for all contents in =${HOME}/.runcom/dotfiles= in =${HOME}=.
    - If =stow= finds a pre-existing directory, symlinks are created inside that directory.
    - If =stow= finds a pre-existing file (non-directory), it throws error.
**** Preserve 'current' configuration in a *visible* folder in =${HOME}=
     #+begin_src sh :tangle setup/setup.sh
       presernce="${HOME}/OLD_CONFIG"
       mkdir -p "${presence}"
       cat << EOR >> "${presence}/README.md"
       This directory contains a backup of configuration that existed before runcom setup.
       Files in this directory may be merged to their respective place after inspection.
       I recommend that this directory should **NOT** deleted.
       It will be required during un-doing the setup.
       EOR
     #+end_src

**** Create directories, so that symlinks are made /inside/ them.
     #+begin_src sh :tangle setup/setup.sh
       for conf_mask in "${HOME}/.runcom/dotfiles/.config"/*; do
           if [ -d "${conf_mask}" ]; then
               hard_directory="${HOME}/.config/${conf_mask##*/}"
               if ! mkdir "${hard_directory}" 2>/dev/null; then
                   mv "${hard_directory}" "${presence}/${hard_directory}"
               fi
               if ! mkdir "${hard_directory}" 2>/dev/null; then
                   # still no luck
                   printf "%s Couldn't be removed and backed up\n"
                   printf "This *shall* cause stow error\n"
               fi
           fi
       done
       for data_mask in "${HOME}/.runcom/dotfiles/.local/share"/*; do
           if [ -d "${conf_mask}" ]; then
               hard_directory="${HOME}/.local/share/${data_mask##*/}"
               if ! mkdir "${hard_directory}" 2>/dev/null; then
                   mv "${hard_directory}" "${presence}/${hard_directory}"
               fi
               if ! mkdir "${hard_directory}" 2>/dev/null; then
                   # still no luck
                   printf "%s Couldn't be removed and backed up\n"
                   printf "This *shall* cause stow error\n"
               fi
           fi
       done
       unset hard_directory
       unset non_mt_msg
     #+end_src

**** Stow
     #+begin_src sh :tangle no
       stow -vS -t "${HOME}" -d "${HOME}/.runcom" dotfiles
     #+end_src

     #+begin_src sh :tangle setup/setup.sh :exports none
       }
        stow_deploy() {
            if ! stow -vS -t "${HOME}" -d "${HOME}/.runcom" dotfiles; then
                # stow threw error
                stow_error="$?"
                printf "Fix above errors and try again."
                exit "${stow_error}"
            fi
        }

        main () {
            clone_repo
            mask_stow_directories
            stow_deploy
        }
        main "$@"
     #+end_src

* Undo Setup
  #+begin_warning
  Do *NOT* use =sudo= during unset.
  #+end_warning

  #+begin_note
  - The next steps will require a directory containing 'old configuration files'.
  - You HAD BEEN warned against deleting it during the setup.
  #+end_note

** Bootstrap unset using script
   - Unset may be bootstrapped by running the [[./setup/unset.sh][unset]] script.

     #+BEGIN_SRC sh :tangle no
       curl -sLf "https://pradyparanjpe.github.io/runcom/setup/unset.sh" | sudo sh

     #+END_SRC

     #+begin_note
     Inspecting scripts before running them is generally a good idea.
     The /unset/ script is tangled (with automation wrappers) from the code below.
     If you feel an urge to inspect it or if it fails,
     follow manual unset instructions with modifications instead.
     #+end_note

** Guide for manual un-setup.

   #+BEGIN_SRC sh :tangle setup/unset.sh :exports none
     #!/usr/bin/env sh
     # -*- coding: utf-8; mode: shell-script; -*-
   #+end_src

*** UnStow dotfiles
    - Use =GNU stow= to unstow to un-linked structure for all contents in =${HOME}/.runcom/dotfiles= from =${HOME}=.
**** UnStow
     #+begin_src sh :tangle no
       stow -vp -t "${HOME}" -d "${HOME}/.runcom" -D dotfiles

     #+end_src

     #+begin_src sh :tangle setup/unset.sh :exports none
       unstow_undeploy() {
           if ! stow -vp -t "${HOME}" -d "${HOME}/.runcom" -D dotfiles; then
               # stow threw error
               stow_error="$?"
               printf "Fix above errors and try again."
               exit "${stow_error}"
           fi
       }

       restore_configurations() {

     #+end_src

**** Restore directories form =${HOME}/OLD_CONFIG=
     #+begin_src sh :tangle setup/unset.sh
       for conf_dir in "${1:-${HOME}/OLD_CONFIG}"/*; do
           cp -r "${conf_dir}" "${HOME}"/. || break
       done

       # shellcheck disable=SC2181
       if [ $? -ne 0 ]; then
           printf "Restoration unsuccessful, copy backup files manually.\n"
       else
           printf "Restoration successful, backup directory may be deleted.\n"
       fi
     #+end_src

*** Delete runcom
    Goodbye

    #+BEGIN_SRC sh :tangle setup/unset.sh :exports none
      }

       delete_repo () {
    #+END_SRC

    #+BEGIN_SRC sh :tangle setup/unset.sh
      rm -rf "${RUNCOMDIR:-${HOME}/.runcom}" && printf "Goodbye âœ‹"
    #+END_SRC

    #+BEGIN_SRC sh :tangle setup/unset.sh :exports none
      }

       main () {
           unstow_undeploy
           restore_configurations "$@"
           delete_repo
       }
       main "$@"
    #+END_SRC

* Personalization
** Local
   Create a directory at the location  =${XDG_CONFIG_HOME:-${HOME}/.config}/local.d=.
   - All files that match the glob =${XDG_CONFIG_HOME:-${HOME}/.config}/local.d/.*rc= are sourced.
   - Do not synchronize this directory. This directory is only for the machine.
     #+begin_src sh :tangle no
       mkdir -p "${XDG_CONFIG_HOME:-${HOME}/.config}/local.d"
     #+end_src

** Synchronized
   Create a directory at the location =${XDG_CONFIG_HOME:-${HOME}/.config}/pvt.d=.
   #+begin_src sh :tangle no
     mkdir -p "${XDG_CONFIG_HOME:-${HOME}/.config}/pvt.d"
   #+end_src

   - All files that match the glob =${XDG_CONFIG_HOME:-${HOME}/.config}/pvt.d/.*rc= are sourced.
   - Synchronize (stow) that directory using a local repository or by simply copying contents.
     #+begin_danger
     - *DO NOT* create this directory inside =${RUNCOMDIR}:-${HOME}/.runcom}/.config=.
     - *DO NOT* synchronize this directory using a public repository.
     - *DO NOT* store passwords in this directory. For password management, use [[https://passwordstore.org][pass]]
     #+end_danger


   #+begin_tip
   - Remember to keep the repository updated.

     #+BEGIN_SRC sh :tangle no
       git pull --recurse-submodules
     #+END_SRC
   #+end_tip

** Proxy settings
   Read set up for [[./proxy_send.html][proxy_send]].

   *_SETUP COMPLETE!_ Following sections explain and tangle the contents of runcom.*
* Structure
  Following configuration files are available. This literate configuration tangles their contents.
  |------------------------------------------------+-------+--------+---------|
  | Configuration File Path                        | POSIX | Stowed | Owner   |
  |------------------------------------------------+-------+--------+---------|
  | /etc/profile                                   | yes   | no     | root    |
  | /etc/bashrc                                    | yes   | no     | root    |
  | /etc/zshrc                                     | yes   | no     | root    |
  | /etc/profile.d/*                               | yes   | no     | root    |
  | ${HOME}/.bashrc                                | no    | yes    | ${USER} |
  | ${HOME}/.zshrc                                 | no    | yes    | ${USER} |
  | ${HOME}/.bash_profile                          | yes   | yes    | ${USER} |
  | ${HOME}/.bash_login                            | yes   | yes    | ${USER} |
  | ${HOME}/.profile                               | yes   | yes    | ${USER} |
  | ${HOME}/.zprofile                              | yes   | yes    | ${USER} |
  | ${HOME}/.zshenv                                | yes   | yes    | ${USER} |
  | ${HOME}/.zlogin                                | yes   | yes    | ${USER} |
  | ${RUNCOMDIR}/shrc                              | yes   | no     | RUNCOM  |
  | ${RUNCOMDIR}/ui                                | yes   | no     | RUNCOM  |
  | ${XDG_DATA_HOME}/bash-completion/completions/* | no    | yes    | ${USER} |
  | ${XDG_CONFIG_DIR}                              | no    | yes    | ${USER} |
  | ${XDG_CONFIG_HOME}/local.d/.*rc                | yes   | no     | ${USER} |
  | ${XDG_CONFIG_HOME}/pvt.d/.*rc                  | yes   | pvt    | ${USER} |
  |------------------------------------------------+-------+--------+---------|
  They are loaded in following order.

** Bash
*** /etc/profile
**** /etc/bashrc
***** /etc/profile.d/*

*** ${HOME}/.bash_profile
**** ${HOME}/.profile

**** ${HOME}/.bashrc
****** ${RUNCOMDIR}/shrc
******* ${XDG_CONFIG_HOME}/local.d/*
******* ${XDG_CONFIG_HOME}/pvt.d/*

**** ${HOME}/.bash_login
****** ${RUNCOMDIR}/ui

** Zsh
*** /etc/profile
**** /etc/zshrc
***** /etc/profile.d/*

*** ${HOME}/.zshenv

*** ${HOME}/.zprofile
**** ${HOME}/.profile

*** ${HOME}/.zshrc
***** ${RUNCOMDIR}/shrc
****** ${XDG_CONFIG_HOME}/local.d/*
****** ${XDG_CONFIG_HOME}/pvt.d/*

*** ${HOME}/.zlogin
***** ${RUNCOMDIR}/ui

* Headers
  Copyright, License banners
  #+BEGIN_SRC sh :tangle shrc :exports none :noweb-ref posix-check
    # shellcheck shell=sh
  #+end_src

  #+BEGIN_SRC sh :tangle shrc :exports none :noweb-ref banner
    # -*- coding:utf-8; mode:shell-script; -*-
    #
    # Copyright 2020, 2021 Pradyumna Paranjape
    #
    # This file is part of Prady_runcom.
    #
    # Prady_runcom is free software: you can redistribute it and/or modify
    # it under the terms of the GNU General Public License as published by
    # the Free Software Foundation, either version 3 of the License, or
    # (at your option) any later version.
    #
    # Prady_runcom is distributed in the hope that it will be useful,
    # but WITHOUT ANY WARRANTY; without even the implied warranty of
    # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    # GNU General Public License for more details.
    #
    # You should have received a copy of the GNU General Public License
    # along with Prady_runcom.  If not, see <https://www.gnu.org/licenses/>.
    #
    #===================================================================
    #  ___             _      ___                     _
    # | _ \_ _ __ _ __| |_  _| _ \__ _ _ _ __ _ _ _  (_)_ __  ___
    # |  _/ '_/ _` / _` | || |  _/ _` | '_/ _` | ' \ | | '_ \/ -_)
    # |_| |_| \__,_\__,_|\_, |_| \__,_|_| \__,_|_||_|/ | .__/\___|
    #                    |__/                      |__/|_|
    #===================================================================

  #+end_src

  #+BEGIN_SRC bash :tangle dotfiles/.bashrc :exports none :noweb-ref bash-check
    # shellcheck shell=bash
  #+end_src

  #+BEGIN_SRC bash :tangle dotfiles/.bashrc :exports none :noweb yes
    <<banner>>
  #+END_SRC

  #+BEGIN_SRC bash :tangle dotfiles/.zshrc :exports none :noweb yes
    <<bash-check>>
    <<banner>>
  #+END_SRC

  #+BEGIN_SRC bash :tangle dotfiles/.bash_login :exports none :noweb yes
    <<posix-check>>
    <<banner>>
  #+END_SRC

  #+BEGIN_SRC bash :tangle dotfiles/.zshenv :exports none :noweb yes
    <<posix-check>>
    <<banner>>
  #+END_SRC

  #+BEGIN_SRC bash :tangle dotfiles/.zlogin :exports none :noweb yes
    <<posix-check>>
    <<banner>>
  #+END_SRC

  #+BEGIN_SRC sh :tangle dotfiles/.profile :exports none :noweb yes
    <<posix-check>>
    <<banner>>
  #+END_SRC

  #+BEGIN_SRC sh :tangle ui :exports none :noweb yes
    <<posix-check>>
    <<banner>>
  #+END_SRC

* Profiles
  #+BEGIN_SRC bash :tangle dotfiles/.bash_profile
    if [ -f "${HOME}/.profile" ]; then
        # shellcheck disable=SC1091
        . "${HOME}/.profile"
    fi

    if [ -f "${HOME}/.bashrc" ]; then
        # shellcheck disable=SC1091
        . "${HOME}/.bashrc"
    fi

    if [ -f "${HOME}/.bash_login" ]; then
        # shellcheck disable=SC1091
        . "${HOME}/.bash_login"
    fi

  #+END_SRC

  #+BEGIN_SRC bash :tangle dotfiles/.zprofile
    # shellcheck source=".profile"
    if [ -f "${HOME}"/.profile ]; then
        # shellcheck disable=SC1091
        . "${HOME}"/.profile
    fi
  #+END_SRC

  #+begin_src bash :tangle dotfiles/.zshrc
    # The following lines were added by compinstall

    zstyle ':completion:*' completer _complete _ignored _approximate
    zstyle ':completion:*' list-colors ''
    zstyle ':completion:*' matcher-list ''
    zstyle ':completion:*' max-errors 2
    zstyle ':completion:*' menu select=3
    zstyle ':completion:*' select-prompt %SScrolling \
           active: current selection at %p%s
    zstyle :compinstall filename "${HOME}/.zshrc"

    # End of lines added by compinstall
    # Lines configured by zsh-newuser-install

  #+end_src

* Init
** bash
   - Prevent bashrc from running outside non-interactive mode
   #+BEGIN_SRC bash :tangle dotfiles/.bashrc
     case $- in
         ,*i*)
         ;;
         ,*)
             return
             ;;
     esac
   #+END_SRC

   - Option settings
   #+BEGIN_SRC bash :tangle dotfiles/.bashrc
     shopt -s autocd
     shopt -s checkwinsize
     shopt -s globstar
   #+END_SRC

   - History
   #+BEGIN_SRC bash :tangle dotfiles/.bashrc
     shopt -s histappend
     HISTCONTROL=ignoreboth
     HISTSIZE=10000
     HISTFILESIZE=10000
   #+END_SRC

   - Colored terminals
   #+BEGIN_SRC bash :tangle dotfiles/.bashrc
     case "$TERM" in
         xterm-color|*-256color) color_prompt=yes;;
     esac
   #+END_SRC

   - Keybindings
   #+BEGIN_SRC bash :tangle dotfiles/.bashrc
     set -o vi
     bind '"jk":vi-movement-mode'
   #+END_SRC

** zsh
   Settings
   - History
   #+BEGIN_SRC bash :tangle dotfiles/.zshrc
     HISTFILE="${XDG_CACHE_HOME:-${HOME}/.cache}/.zhistory"
     HISTSIZE=10000
     SAVEHIST=10000
   #+END_SRC

   - Options
     #+BEGIN_SRC bash :tangle dotfiles/.zshrc
       ZSH_AUTOSUGGEST_HIGHLIGHT_STYLE="fg=#5f6f7f,bg=#172737"
       ZSH_AUTOSUGGEST_STRATEGY=("history" "completion")
       setopt autocd
       setopt interactive_comments
       setopt appendhistory extendedglob notify
       setopt BANG_HIST                 # Treat the '!' character specially during expansion.
       setopt EXTENDED_HISTORY          # Write the history file in the ":start:elapsed;command" format.
       setopt INC_APPEND_HISTORY        # Write to the history file immediately, not when the shell exits.
       setopt HIST_EXPIRE_DUPS_FIRST    # Expire duplicate entries first when trimming history.
       setopt HIST_IGNORE_DUPS          # Don't record an entry that was just recorded again.
       setopt HIST_IGNORE_ALL_DUPS      # Delete old recorded entry if new entry is a duplicate.
       setopt HIST_FIND_NO_DUPS         # Do not display a line previously found.
       setopt HIST_SAVE_NO_DUPS         # Don't write duplicate entries in the history file.
       setopt HIST_IGNORE_SPACE         # Don't record an entry starting with a space.
       setopt HIST_REDUCE_BLANKS        # Remove superfluous blanks before recording entry.
       setopt HIST_VERIFY               # Don't execute immediately upon history expansion.
       unsetopt beep
       autoload colors && colors
       autoload add-zsh-hook
       autoload -Uz compinit
       autoload -Uz bashcompinit
       compinit
       bashcompinit
     #+END_SRC

   - Keybindings
     #+BEGIN_SRC bash :tangle dotfiles/.zshrc
       term_key_source="${HOME}/.zkbd/$TERM-${${DISPLAY:t}:-$VENDOR-$OSTYPE}"
       if [ -f "${term_key_source}" ]; then
           source "${term_key_source}"
       fi
       # keybindings
       bindkey -v
       bindkey -s '^o' 'lfcd\n'
       bindkey -s '^f' 'fzfcd\n'
       bindkey -s '^E' 'deactivate 2>/dev/null || true\n'
       bindkey -s '^N' 'force_global_venv\n'
       bindkey '^[[P' delete-char  # backspace key
       bindkey '^[[1;5D' vi-backward-word  # ctrl <-
       bindkey '^[[1;5C' vi-forward-word  # ctrl ->
       bindkey '^[[3~' vi-delete-char  # delete key
       bindkey '^[[F' vi-end-of-line  # end key
       bindkey '^[[H' vi-beginning-of-line  # home key
       bindkey "^[[27;2;13~" vi-open-line-below  # shift Return
       export KEYTIMEOUT=10

       # Use beam shape cursor for each new prompt.
       _fix_cursor () {
           echo -ne '\e[6 q'
       }
       add-zsh-hook precmd _fix_cursor

       # Change cursor shape for different vi modes.
       zle-keymap-select () {
           if [ "${KEYMAP}" = "vicmd" ] ||
                  [ "${1}" = 'block' ]; then
               printf '\e[2 q'

           elif [ "${KEYMAP}" = "main" ] ||
                    [ "${KEYMAP}" = "viins" ] ||
                    [ "${KEYMAP}" = '' ] ||
                    [ "${1}" = 'beam' ]; then
               printf '\e[6 q'
           elif [ "${KEYMAP}" = "visual" ]; then
               printf '\e[4 q'
           fi
       }
       # Use vim keys in tab complete menu:
       zmodload zsh/complist
       zmodload zsh/mapfile
       bindkey -M menuselect 'h' vi-backward-char
       bindkey -M menuselect 'k' vi-up-line-or-history
       bindkey -M menuselect 'l' vi-forward-char
       bindkey -M menuselect 'j' vi-down-line-or-history
       bindkey -v '^?' backward-delete-char
       bindkey -M viins 'jk' vi-cmd-mode
       bindkey '^r' history-incremental-search-backward

       zle -N zle-keymap-select

     #+END_SRC
   - Unset options:
     - setopt SHARE_HISTORY             # Share history between all sessions.
     - setopt HIST_BEEP                 # Beep when accessing nonexistent history.
     - HISTCONTROL=ignoreboth           # ignore commands staring with " " and duplicate

* Inherit
** bash
   #+BEGIN_SRC bash :tangle dotfiles/.bashrc
     # shellcheck source=".runcom/shrc"
     if [ -f "${RUNCOMDIR:-${HOME}/.runcom}/shrc" ]; then
         . "${RUNCOMDIR:-${HOME}/.runcom}/shrc"
     fi
     if [ -f "${RUNCOMDIR:-${HOME}/.runcom}/bash-preexec/bash-preexec.sh" ]; then
         . "${RUNCOMDIR:-${HOME}/.runcom}/bash-preexec/bash-preexec.sh"
     fi
   #+END_SRC

** zsh
   #+BEGIN_SRC bash :tangle dotfiles/.zshrc
     # shellcheck source=".runcom/shrc"
     if [ -f "${RUNCOMDIR:-${HOME}/.runcom}/shrc" ]; then
         . "${RUNCOMDIR:-${HOME}/.runcom}/shrc"
     fi
     while read -r addition; do
         while read -r share_dir; do
             add_dir="${share_dir}/zsh-${addition}"
             if [ -d "${add_dir}" ]; then
                 # shellcheck disable=SC1090
                 . "${add_dir}/zsh-${addition}.zsh"
                 break
             fi
         done << data_dir
     /usr/local/share
     /usr/share
     ${XDG_DATA_HOME:-${HOME}/.local/share}
     ${XDG_DATA_HOME:-${HOME}/.local/share}/pspman/local/share
     ${HOME}/local/share
     ${HOME}/share
     data_dir
     done << addlist
     syntax-highlighting
     autosuggestions
     addlist

     unset addition
     unset share_dir
     unset add_dir

   #+END_SRC

** shrc
*** Local unsynced changes
    All files =${XDG_CONFIG_HOME:-${HOME}/.config}/{local,pvt}.d/.*rc=
    #+BEGIN_SRC sh :tangle shrc
      # shellcheck disable=SC1090
      for unsync_d in local.d pvt.d; do
          for rcfile in "${XDG_CONFIG_HOME:-${HOME}/.config}/${unsync_d}"/.*rc; do
              . "${rcfile}"
          done 2>/dev/null
      done 2>/dev/null

      unset rcfile
      unset unsync_d
    #+END_SRC

* Better alternatives
** cat
   #+BEGIN_SRC sh :tangle shrc
     if builtin command -v 'bat' >/dev/null 2>&1; then
         alias cat="bat --color=auto";
     fi
   #+END_SRC

** g/re/p
   #+BEGIN_SRC sh :tangle shrc
     for sc in "ack" "pt" "ag" "rg"; do
         if builtin command -v "${sc%% *}" >/dev/null 2>&1; then
             # shellcheck disable=SC2139
             alias grep="${sc} --color=auto";
         fi
     done
   #+END_SRC

** List Contents
   #+BEGIN_SRC sh :tangle shrc
     if builtin command -v "exa" >/dev/null 2>&1; then
         alias ls="exa -Fh --color=auto";
         alias la='exa -a --color=auto';
         alias ll='exa -lr -s size';
         alias lla='exa -a';
         alias l.='exa -a --color=auto |grep "^\."';
         alias sl="ls";
     fi
   #+END_SRC

** neo visual editor improved
   #+BEGIN_SRC sh :tangle shrc
     if builtin command -v nvim >/dev/null 2>&1; then
         alias ex="nvim"; # always open vim in normal mode
         alias vim="nvim"; # always use neo
     fi
   #+END_SRC

** Container
   #+BEGIN_SRC sh :tangle shrc
     if builtin command -v podman >/dev/null 2>&1; then
         alias docker="podman";  # Podman is drop-in replacement for docker
         alias docker-compose="podman-compose";  # Podman is drop-in replacement for docker
     fi
   #+END_SRC

* Variables
** XDG
   XDG standard locations specifications these can be redefined in
   =${XDG_CONFIG_HOME:-${HOME}/.config}/pvt.d/.<some name>rc=

   #+BEGIN_SRC sh :tangle dotfiles/.profile
     XDG_CACHE_HOME="${HOME}/.cache"
     XDG_CONFIG_HOME="${HOME}/.config"
     XDG_DATA_HOME="${HOME}/.local/share"
     XDG_STATE_HOME="${HOME}/.local/state"
     RUNCOMDIR="${HOME}/.runcom"

     export XDG_CACHE_HOME
     export XDG_CONFIG_HOME
     export XDG_DATA_HOME
     export XDG_STATE_HOME
     export RUNCOMDIR
   #+END_SRC

** PATH
   #+BEGIN_SRC sh :tangle dotfiles/.profile
     # shellcheck source="bin"
     if [ -d "${HOME}/bin" ] ; then
         if [ "${PATH#*${HOME}/bin}" = "${PATH}" ]; then
             PATH="${HOME}/bin:${PATH}"
         fi
     fi

     # shellcheck source=".local/bin"
     if [ -d "${HOME}/.local/bin" ] ; then
         if [ "${PATH#*${HOME}/.local/bin}" = "${PATH}" ]; then
             PATH="${HOME}/.local/bin:${PATH}"
         fi
     fi
     export PATH;
   #+END_SRC

** Editor wars
   #+BEGIN_SRC sh :tangle dotfiles/.profile
     while read -r avail; do
         if builtin command -v "${avail}" >/dev/null 2>&1; then
             EDITOR="${avail}"
         fi
     done << EOF
     nano
     vi
     vim
     nvim
     EOF
     export EDITOR

     case "$EDITOR" in
         vim)
             export MANPAGER='/bin/bash -c "vim -MRn -c \"set buftype=nofile showtabline=0 ft=man ts=8 nomod nolist norelativenumber nonu noma\" -c \"normal L\" -c \"nmap q :qa<CR>\"</dev/tty <(col -b)"'
             ;;
         nvim)
             export MANPAGER="nvim -c ':Man!' -"
             ;;
         ,*)
             if builtin command -v bat; then
                 export MANPAGER='bat -l man -p'
             fi
             ;;
     esac
     export MANPAGER
   #+END_SRC

** C(++) exports
   #+BEGIN_SRC sh :tangle dotfiles/.profile
     LD_LIBRARY_PATH="${HOME}/.local/lib:${HOME}/.local/lib64";
     C_INCLUDE_PATH="${HOME}/.local/share/pspman/include/"
     CPLUS_INCLUDE_PATH="${HOME}/.local/share/pspman/include/"
     export LD_LIBRARY_PATH
     export C_INCLUDE_PATH
     export CPLUS_INCLUDE_PATH
   #+END_SRC

** GPU exports
   #+BEGIN_SRC sh :tangle dotfiles/.profile
     PYOPENCL_CTX='0';
     PYOPENCL_COMPILER_OUTPUT=1;
     OCL_ICD_VENDORS="/etc/OpenCL/vendors/";
     export PYOPENCL_CTX
     export PYOPENCL_COMPILER_OUTPUT
     export OCL_ICD_VENDORS
   #+END_SRC

** Bemenu exports
   #+BEGIN_SRC sh :tangle shrc
     export BEMENU_OPTS='--fn firacode 14 '
   #+END_SRC

** GTK+ debugging output
   Silence debugging output for gtk+
   #+BEGIN_SRC sh :tangle dotfiles/.profile
     NO_AT_BRIDGE=1
     export NO_AT_BRIDGE
   #+END_SRC

* Functions
** Python
*** Python version
    to locate site-packages

    #+BEGIN_SRC sh :tangle shrc
      python_ver() {
          python --version |cut -d "." -f1,2 |sed 's/ //' |sed 's/P/p/'
      }
    #+END_SRC

*** Quickly change to virtualenv
    Scan upto mountpoint, if any direct parent has .venv, source that ".venv/bin/activate"
    This may require shell-identification for ksh, csh, fish since they have a different activate
    #+BEGIN_SRC sh :tangle shrc
      to_venv () {
          test_d="$(realpath "${PWD}")"
          parents=16  # path too long to waste time
          until mountpoint "${test_d}" > /dev/null 2> /dev/null; do
              if [ $parents -le 0 ]; then
                  printf "Too many branch-nodes searched" >&2
                  unset parents
                  unset test_d
                  unset env_d
                  return 126
              fi
              for env_d in ".venv" "venv"; do
                  if [ -d "${test_d}/${env_d}" ] \
                         || [ -L "${test_d}/${env_d}" ]; then
                      # shellcheck disable=SC1090
                      . "${test_d}/${env_d}/bin/activate"
                      printf "Found %s, switching...\n" "${test_d}/${env_d}"
                      unset parents
                      unset test_d
                      unset env_d
                      return 0
                  fi
              done
              test_d="$(dirname "${test_d}")"
              parents=$((parents - 1))
          done
          printf "Couldn't find .venv upto mountpoint %s\n" "${test_d}" >&2
          unset parents
          unset test_d
          unset env_d
          return 126
      }
    #+END_SRC

*** Virtualenv in prompt string
    #+BEGIN_SRC sh :tangle shrc
      _show_venv () {
          # if a virtualenv is active, print it's name
          if [ -n "${VIRTUAL_ENV}" ]; then
              base="$(basename "${VIRTUAL_ENV}")"
              if [ "${base}" = ".venv" ] || [ "${base}" = "venv"  ]; then
                  printf "/%s" "$(basename "$(dirname "${VIRTUAL_ENV}")")"
                  unset base
              else
                  printf "/%s" "${base}"
                  unset base
              fi
          fi
      }
    #+END_SRC
** Git
*** Status
    #+BEGIN_SRC sh :tangle shrc
      git_status() {
          _modified=0
          _cached=0
          _untracked=0

          while read -r _line; do
              case "${_line}" in
                  _*_\ _)
                      _cached=1
                      ;;
                  _\ _*_)
                      _modified=1
                      ;;
                  _?_?_)
                      _untracked=1
                      ;;
              esac
          done << endstat
      $(git status --short | cut -b -2 | sed -e 's/\(.\)\(.*\)/_\1_\2_/')
      endstat

          _stat_str=''
          if [ "$_modified" -ne 0 ]; then
              _stat_str="${_stat_str}\033[0;31m\ue728"
          fi

          if [ "$_cached" -ne 0 ]; then
              _stat_str="${_stat_str}\033[0;32m\ue729"
          fi

          if [ "$_untracked" -ne 0 ]; then
              _stat_str="${_stat_str}\033[0;31m\uf476"
          fi

          if [ -n "$(git stash list)" ]; then
              _stat_str="${_stat_str}\e[0;36m\uf48e"
          fi
          if [ -n "${_stat_str}" ]; then
              # shellcheck disable=SC2059  # I do want escape characters
              printf "${_stat_str}\e[m"
          fi
          unset _modified
          unset _cached
          unset _untracked
          unset _stat_str
      }
    #+END_SRC

*** Branch
    #+BEGIN_SRC sh :tangle shrc
      git_branch() {
          branch_str=''
          branch="$(git branch 2>/dev/null | grep '^\*' | sed -e 's/^* //')"
          if [ -n "${branch}" ]; then
              case "${branch}" in
                  feat-*)
                      branch_str="${branch_str}\033[0;32m"
                      ;;
                  bug-*)
                      branch_str="${branch_str}\033[0;31m"
                      ;;
                  act-*)
                      branch_str="${branch_str}\e[0;36m"
                      ;;
                  tmp-*)
                      branch_str="${branch_str}\e[0;36m"
                      ;;
                  ,*HEAD\ detached*|,*rebasing*)
                      branch_str="${branch_str}\e[0;33m"
                      ;;
                  main|master)
                      unset branch
                      unset branch_str
                      return
                      ;;
                  ,*)
                      branch_str="${branch_str}\e[0;35m"
                      ;;
              esac
          fi
          printf "${branch_str}%s\ue725\e[m" "${branch}"
          unset branch_str
          unset branch
      }

    #+END_SRC
*** Hash
    #+BEGIN_SRC sh :tangle shrc
      git_hash() {
          git log --pretty=format:'%h' -n 1
      }
    #+END_SRC

*** Prompt string
    Include git's branch, hash, status in PS1 if in git repository
    This function is called in PS1 section below
    #+NAME: Git PS
    #+BEGIN_SRC sh :tangle shrc
      git_ps() {
          if ! git status --ignore-submodules >/dev/null 2>&1; then
              return
          else
              printf " %s%s%s " "$(git_branch)" "$(git_hash)" "$(git_status)"
          fi
      }
    #+END_SRC

** Prompt String
*** Exit_color
    #+BEGIN_SRC sh :tangle shrc
      last_exit_color () {
          case "$1" in
              0)
                  # success
                  printf "\e[0;32m"
                  ;;
              1)
                  # general error
                  printf "\e[0;33m"
                  ;;
              2)
                  # misuse of shell builtins
                  printf "\e[0;31m"
                  ;;
              126)
                  # cannot execute
                  printf "\e[0;37m"
                  ;;
              127)
                  # command not found
                  printf "\e[0;30m"
                  ;;
              255)
                  # exit status limit
                  printf "\e[0;31m"
                  ;;
              ,*)
                  if [ "$1" -gt "63" ] && [ "$1" -lt "84" ]; then
                      # syserror.h
                      printf "\e[0;91m"

                  elif [ "$1" -gt "127" ] && [ "$1" -lt "191" ]; then
                      # Fatal error
                      printf "\e[0;41m"
                  else
                      printf "\e[0;31m"
                  fi
                  unset _err
                  ;;
          esac
      }
    #+END_SRC

*** Elapsed_time
    #+BEGIN_SRC sh :tangle shrc
      _elapsed_time() {
          # $1 is start time $2 is end time
          _cmd_start="$1"
          _cmd_end="$2"
          if [ -z "$_cmd_end" ] || [ -z "$_cmd_start" ]; then
              return
          fi
          _sec=$(( _cmd_end - _cmd_start ))
          unset _cmd_start
          unset _cmd_end
          if [ "$_sec" -le 0 ]; then
              return
          fi
          if [ "$_sec" -le 60 ]; then
              printf "%s" "${_sec}"
              unset _sec
              return
          fi
          _min=$(( _sec/60 ))
          unset _sec
          if [ "$_min" -le 60 ]; then
              printf "%sm" "${_min}"
              unset _min
              return
          fi
          _hr=$(( _min/60 ))
          unset _min
          if [ "$_hr" -le 24 ]; then
              printf "%sh" "${_hr}"
              unset _hr
              return
          fi
          _day=$(( _hr/24 ))
          unset _min
          printf "%sd" "${_day}"
          unset _day
      }
    #+END_SRC

*** PROMPT_COMMAND
**** bash
     #+BEGIN_SRC bash :tangle dotfiles/.bashrc
       # export PROMPT_COMMAND=__prompt_command

       preexec() {
           _cmd_start_t="${SECONDS}"
       }

       precmd () {
           _exit_color="$(last_exit_color $?)"

           _elapsed="$(_elapsed_time $_cmd_start_t ${SECONDS})"
           unset _cmd_start_t

           # unset previous
           PS1=""
           PS2=""
           PS3=""
           PS4=""
           RPROMPT=""

           PS1+="\[\e[0;32m\]\u\[\e[m\]"
           PS1+="\[\e[3;35m\]\$(_show_venv)\[\e[m\]"
           PS1+="@"
           PS1+="\[\e[0;34m\]\h\[\e[m\]"
           PS1+="\$(git_ps)"
           PS1+="\[\e[0;36m\]:\W"
           PS1+="\[\e[0;37m\]"

           PS1+="$(date '+%H:%M:%S')"
           PS1+=" ${_exit_color}-${_elapsed}"
           PS1+='\[\e[m\]\nÂ» '

           PS2=""
           PS2+="\[\e[0;36m\]cont..."
           PS2+="\[\e[m\]"
           PS2+="Â» ";

           PS3='Selection: ';
       }
     #+END_SRC

**** zsh
     #+BEGIN_SRC bash :tangle dotfiles/.zshrc
       _pspexec() {
           _cmd_start_t="${SECONDS}"
       }

       _pspps () {
           _exit_color="$(last_exit_color $?)"

           _elapsed="$(_elapsed_time $_cmd_start_t ${SECONDS})"
           unset _cmd_start_t

           # unset previous
           PS1=$''
           PS2=$''
           PS3=$''
           PS4=$''
           RPROMPT=$''

           PS1+=$'%{\e[0;32m%}%n%{\e[m%}'
           PS1+=$'%{\e[3;35m%}'
           PS1+="$(_show_venv)"
           PS1+=$'%{\e[m%}'
           PS1+=$'@'
           PS1+=$'%{\e[0;34m%}%m%{\e[m%}'
           PS1+="$(git_ps)"
           PS1+=$'%{\e[0;36m%}:%1~'
           PS1+=$'%{\e[0;37m%}\n%{\e[m%}Â» '

           PS2+=$'%{\e[0;36m%}cont...'
           PS2+=$'%{\e[m%}'
           PS2+=$'Â» '

           PS3='Selection: '

           RPROMPT+=$'%*'
           RPROMPT+="%{$_exit_color%}-${_elapsed}"
           RPROMPT+=$'%{\e[m%}'
           unset _exit_stat
           unset _elapsed
       }

       add-zsh-hook precmd _pspps
       add-zsh-hook preexec _pspexec

     #+END_SRC

** Mathematical
*** In-Line Calculator
    #+BEGIN_SRC sh :tangle shrc
      mathcalc() {
          echo "$*"| bc -lq
      }
    #+END_SRC

*** Computational
    #+BEGIN_SRC sh :tangle shrc
      dec2hex() {
          echo "hex:"
          echo "obase=16; $*"| bc
          echo "dec:"
          echo "ibase=16; $*"| bc
      }
    #+END_SRC

** Documents compilation
*** PDF from Latex
    #+BEGIN_SRC sh :tangle shrc
      pdfcompile() {
          if ! builtin command -v "pdflatex" 1>/dev/null 2>&1; then
              printf "pdftex is not installed\n"
              return 127
          fi

          pdflatex "$1"
          for ext in ".toc" ".log" ".aux"; do
              [ -f "${1%.tex}${ext}" ] && rm "${1%.tex}${ext}"
          done
          if builtin command -v "pdflatex" 1>/dev/null 2>&1; then
              zathura "${1%.tex}.pdf"
          fi
      }
    #+END_SRC
*** Pandoc
**** Org to Something
     #+BEGIN_SRC sh :tangle shrc
       org2export() {
           # Usage: org2oth [-f] <infile> <othtype>
           if ! builtin command -v "pandoc" 1>/dev/null 2>&1; then
               printf "pandoc is not installed\n"
               return 127
           fi
           proceed=false
           while test $# -gt 1; do
               case "$1" in
                   -f|--force)
                       proceed=true
                       shift 1
                       ;;
                   -h|--help)
                       printf "Usage: org2export [-h|--help] [-f|--force] FILENAME.org OUTFMT\n\n"
                       printf "Optional Arguments:\n"
                       printf "%s\tshow this help message\n\n" "-h|--help"
                       printf "%s\tignore extension mismatch\n" "-f|--force"
                       printf "Positional Arguments:\n"
                       printf "FILENAME.org\tpath to input filename\n"
                       printf "OUTFMT\t\tformat of output [pdf, docs, ...]\n"
                       return 0
                       ;;
                   --)
                       shift 1
                       ;;
                   ,*)
                       infile="${1}";
                       target="${2}";
                       break
                       ;;
               esac
           done
           if [ "${target}" = "pdf" ]; then
               target="latex"
           fi
           if [ "${infile%.org}" = "${infile}" ]; then
               # <infile>
               printf "Input file should be an org file\n"
           else
               # <infile>.org
               proceed=true
           fi
           if $proceed; then
               pandoc -f org -t "${target}" -o "${infile%.*}.${1}" "$infile"
           fi
           unset proceed
           unset target
           unset infile
       }
     #+END_SRC

**** Org to Docx
     #+BEGIN_SRC sh :tangle shrc
       org2doc () {
           org2export "$@" "docx"
       }
     #+END_SRC

**** Org to PDF
     #+BEGIN_SRC sh :tangle shrc
       org2pdf () {
           org2export "$@" "pdf"
       }
     #+END_SRC

**** Docx to Org
     #+BEGIN_SRC sh :tangle shrc
       doc2org() {
           if ! builtin command -v "pandoc" 1>/dev/null 2>&1; then
               printf "pandoc is not installed\n"
               return 127
           fi

           case "${1}" in
               ,*.docx)
                   pandoc -f docx -t org -o "${1%.docx}.org" "$1"
                   ;;
               ,*)
                   echo "Input file must be a docx file"
                   ;;
           esac
       }
     #+END_SRC

** Mount over ssh
   ssh Cloud mounts
   - see [[./cloud_mount.html][cloud_mount]]
   #+BEGIN_SRC sh :tangle shrc
     mount_cloud_sshfs() {
         mount_script="${RUNCOMDIR:-${HOME}/.runcom}/bin/cloud_mount.sh"
         if [ -f "${mount_script}" ]; then
             eval "${mount_script}"
         fi
     }

     umount_cloud_sshfs() {
         mount_script="${RUNCOMDIR:-${HOME}/.runcom}/bin/cloud_mount.sh"
         if [ -f "${mount_script}" ]; then
             eval "${mount_script}" "umount"
         fi
     }

   #+END_SRC

** Launch gui
   Launch application and exit terminal window
   Acts like a launcher
   Uninteractive terminal commands may also be called
   Code is tangled in gui.org
   #+BEGIN_SRC sh :tangle shrc
     gui () {
         "${RUNCOM:-${HOME}/.runcom}/bin/gui.sh" "$*"
         if [ $? = 65 ]; then
             # if bin/gui.sh returns 65, kill shell, else, maintain
             exit 0
         fi
     }
   #+END_SRC

** Un-Compress by context
   #+BEGIN_SRC sh :tangle shrc
     deconvolute() {
         if builtin command -v "pigz"; then
             _gzip="pigz"
         else
             _gzip='gzip'
         fi
         if [ ! -f "${1}" ]; then
             echo "${1}: no such file";
         else
             case "${1}" in
                 ,*.tar.bz2) tar -xjf "${1}" ;;
                 ,*.tbz2) tar -xjf "${1}" ;;
                 ,*.tar.gz) tar -x --use-compress-program="${_gzip}" -f "${1}" ;;
                 ,*.tgz) tar -x --use-compress-program="${_gzip}" -f "${1}" ;;
                 ,*.gz) unpigz "${1}" || gunzip "${1}" ;;
                 ,*.rar) unrar -x "${1}" ;;
                 ,*.tar) tar -xf "${1}" ;;
                 ,*.zip) unzip "${1}" ;;
                 ,*.tar.xz) tar -xf "${1}" ;;
                 ,*) echo "Cannot extract ${1}, provide explicit command";;
             esac
         fi
         unset _gzip
     }
   #+END_SRC

** Navigate
   - When no virtualenv is active, but one is available, switch to it
   #+BEGIN_SRC sh :tangle shrc
     cd () {
         if [ -z "${1}" ]; then
             builtin cd "${HOME}" || true
         else
             builtin cd "${1}"  || true
         fi
         if [ -z "${VIRTUAL_ENV}" ]; then
             to_venv 2>/dev/null
         fi
     }
   #+END_SRC

   - Inspired by lukesmith.xyz
   #+BEGIN_SRC sh :tangle shrc
     lfcd () {
         if ! command -v 'lf' >/dev/null 2>/dev/null; then
             printf "lf is not installed\n"
             return 127
         fi
         tmp_file="$(mktemp)"
         lf -last-dir-path="${tmp_file}" "$@"
         if [ -f "${tmp_file}" ]; then
             target_dir="$(cat "${tmp_file}")"
             rm -f "${tmp_file}" >/dev/null
             if [ -d "${target_dir}" ] && [ "${target_dir}" != "$(pwd)" ]; then
                 cd "${target_dir}" || return
             fi
         fi
         unset tmp_file
         unset target_dir
     }

     fzfcd () {
         if ! command -v 'fzf' >/dev/null 2>/dev/null; then
             printf "fzf is not installed\n"
             return 127
         fi
         cd "$(dirname "$(fzf)")" || true
     }
   #+END_SRC

** zwc
   - Guess whether target is zipped;
     if zipped, unzip and count else classical wc
   #+begin_src sh :tangle shrc
     zwc () {
         args="$*"
         fname="${args##* }"
         args="${args% ${fname}}"
         args="${args%${fname}}"

         if gzip -t "${fname}" > /dev/null 2>&1; then
             if [ -z "${args}" ]; then
                 zcat -f "${fname}" | wc
             else
                 # shellcheck disable=SC2086
                 zcat -f "${fname}" | wc $args
             fi
             return
         else
             wc "$@"
             return
         fi

     }
   #+end_src

** disable autovenv
   - To disable autoswitching virtualenvs, hard-set VIRTUAL_ENV
     - Calling the function again reverts
   #+BEGIN_SRC sh :tangle shrc
     force_global_venv () {
         if [ "${VIRTUAL_ENV}" = "Global_Env" ]; then
             unset VIRTUAL_ENV
             to_venv 2>/dev/null
         else
             deactivate 2>/dev/null
             VIRTUAL_ENV="Global_Env"
         fi
     }
   #+END_SRC

** lszcat
   #+begin_src sh :tangle shrc
     lszcat () {
         args="$*"
         fname="${args##* }"
         args="${args%% ${fname}}"
         args="${args%%${fname}}"

         if builtin command -v bat >/dev/null 2>&1; then
             betcat="$(which bat)"
         else
             betcat="$(which cat)"
         fi

         if builtin command -v exa >/dev/null 2>&1; then
             betls="$(which exa)"
         else
             betls="$(which ls)"
         fi

         if [ -z "${fname}" ] || [ ! "${fname#-}" = "${fname}" ]; then
             if [ -z "${args}" ]; then
                 args="${fname}"
             else
                 args="${args} ${fname}"
             fi
             fname="$(readlink -f ".")"
             echo "${fname}"
         fi

         if [ -d "${fname}" ]; then
             # shellcheck disable=SC2086
             "${betls}" ${args} "${fname}"
         elif gzip -t "${fname}" >/dev/null 2>&1; then
             # shellcheck disable=SC2086
             zcat -f ${args} "${fname}" | "${betcat}"
         else
             # shellcheck disable=SC2086
             "${betcat}" ${args} "${fname}"
         fi
     }
   #+end_src

** manual pages
   #+BEGIN_SRC sh :tangle shrc
     man_help () {
         if man "$@"; then
             return 0
         elif tldr "$@"; then
             return 0
         elif builtin command -v "$1" >/dev/null 2>/dev/null; then
             printf "trying to display %s --help output\n" "${1}"
             if builtin command -v 'bat' >/dev/null 2>/dev/null; then
                 $1 --help 2>&1 | bat
             else
                 $1 --help 2>&1 | less -RF
             fi
             return 0
         else
             return 16
         fi
     }
   #+END_SRC

* Aliases
** Disk Usage
   #+BEGIN_SRC sh :tangle shrc
     alias du='du -hc';
     alias df='df -h';
     alias duall="du -hc |\grep '^[3-9]\{3\}M\|^[0-9]\{0,3\}\.\{0,1\}[0-9]\{0,1\}G'";
   #+END_SRC

** manual page help
   #+BEGIN_SRC sh :tangle shrc
     alias man="man_help";
   #+END_SRC
** Network
   #+BEGIN_SRC sh :tangle shrc
     alias nload='nload -u M -U G -t 10000 -a 3600 $(ip a | grep -m 1 " UP " | cut -d " " -f 2 | cut -d ":" -f 1)'
     alias nethogs='\su - -c "nethogs $(ip a | grep  "state UP" | cut -d " " -f 2 | cut -d ":" -f 1) -d 10"';
     alias ping="ping -c 4 ";
   #+END_SRC

** Monitor Job queues
   #+BEGIN_SRC sh :tangle shrc
     alias watch="watch -n 10 --color";
   #+END_SRC

** Lazy single-handed exit
   #+BEGIN_SRC sh :tangle shrc
     alias qqqq="exit";
   #+END_SRC

** [z]wc
   #+begin_src sh :tangle shrc
     alias wc="zwc";
   #+end_src

* Networking
** State
   The *OLDEST* part of prady_runcom...
   - ... although, amended many times
   - see [[./netcheck.html][netcheck]]
   #+BEGIN_SRC sh :tangle shrc
     # shellcheck source=./bin/netcheck.sh
     o_ifs="${IFS}"
     IFS="$(printf "\t")" read -r ip_addr _ netstate << netcheck
     $("${RUNCOMDIR:-${HOME}/.runcom}"/bin/netcheck.sh)
     netcheck
     IFS="${o_ifs}"
     if [ $(( netstate & 8)) ]; then
         printf "\e[1;34mInternet (GOOGLE) Connected\e[m\n"
         if [ ! $(( netstate & 16)) ]; then
             printf "\e[1;35mProblem with DNS\e[m\n"
         fi
         printf "\033[0;32m%s \e[m is current wireless ip address\n" "$ip_addr"
     else
         printf "\e[1;31mInternet (GOOGLE) Not reachable\e[m\n"
         if [ $(( netstate & 4 )) ]; then  # Intranet is connected
             printf "\033[0;31mInternet Down\e[m\n"
             if [ $(( netstate & 2 )) ]; then
                 printf "Home network connected,\n"
             elif [ $(( netstate & 1 )) ]; then
                 printf "OFFICE network connected,\n"
                 # shellcheck source=./bin/proxy_send.sh
                 auto_proxy="${RUNCOMDIR:-${HOME}/.runcom}/bin/proxy_send.sh"
                 if [ -f "${auto_proxy}" ]; then
                     # shellcheck source=./proxy_send.py
                     eval "$auto_proxy" && printf "\e[0;33mPROXY AUTH SENT\e[m\n";
                 fi
                 unset auto_proxy
             else
                 printf "HOTSPOT connected\n"
             fi
         else
             printf "\e[1;33mNetwork connection Disconnected\e[m\n"
         fi
     fi
     unset o_ifs
     unset ip_addr
   #+END_SRC

** SSH Agent
   Reuse ssh agent for all logins
   #+BEGIN_SRC sh :tangle ui
     if [ ! -S "~/.ssh/ssh_auth_sock" ]; then
         eval "$(ssh-agent)"
         ln -sf "$SSH_AUTH_SOCK" ~/.ssh/ssh_auth_sock
     fi
     SSH_AUTH_SOCK=~/.ssh/ssh_auth_sock
     export SSH_AUTH_SOCK
     ssh-add -l > /dev/null || ssh-add
   #+END_SRC

* Window Manager settings
** Terminal
   #+BEGIN_SRC sh :tangle ui
     for term in foot alacritty termite tilix urxvt xterm; do
         if [ -n "$(command -v $term)" ]; then
             defterm="$term";
             export defterm
             break;
         fi;
     done
   #+END_SRC

** Sway exports
   Don't really remember why these were made
   Not using currently. Preserved for future
   tangle to bash_login
   export WLR_BACKENDS="headless";
   export WLR_LIBINPUT_NO_DEVICES=1;

** User Interface (GUI/CLI)
   If running from tty1 setup sway environment and start ui
   #+BEGIN_SRC sh :tangle ui
     _common_exports() {
         if [ -z "$XDG_RUNTIME_DIR" ]; then
             XDG_RUNTIME_DIR="/run/user/$(id -u)"
         fi
         QT_PLUGIN_PATH="/usr/lib/kde4/plugins/"
         QT_AUTO_SCREEN_SCALE_FACTOR=0
         QT_QPA_PLATFORMTHEME="qt5ct"
         _JAVA_AWT_WM_NONREPARENTING=1

         export XDG_RUNTIME_DIR
         export QT_PLUGIN_PATH
         export QT_AUTO_SCREEN_SCALE_FACTOR
         export QT_QPA_PLATFORMTHEME
         export _JAVA_AWT_WM_NONREPARENTING
     }
     _exports_for_sway () {
         # export DISPLAY=":0"
         # export WAYLAND_DISPLAY=wayland-0
         # export GDK_BACKEND=wayland,x11
         _common_exports

         XDG_SESSION_TYPE="wayland"
         SDL_VIDEODRIVER="wayland"
         SWAYROOT="${XDG_CONFIG_HOME:-${HOME}/.config}/sway"
         ECORE_EVAS_ENGINE="wayland_egl"
         ELM_DISPLAY="wl"
         ELM_ENGINE="wayland_egl"
         ELM_ACCEL="opengl"
         QT_QPA_PLATFORM="wayland-egl;xcb"
         QT_WAYLAND_FORCE_DPI=100
         QT_WAYLAND_DISABLE_WINDOWDECORATION=1
         MOZ_ENABLE_WAYLAND=1

         export XDG_SESSION_TYPE
         export SDL_VIDEODRIVER
         export SWAYROOT
         export ECORE_EVAS_ENGINE
         export ELM_DISPLAY
         export ELM_ENGINE
         export ELM_ACCEL
         export QT_QPA_PLATFORM
         export QT_WAYLAND_FORCE_DPI
         export QT_WAYLAND_DISABLE_WINDOWDECORATION
         export MOZ_ENABLE_WAYLAND
     }

     _exports_for_x11 () {
         _common_exports

         XDG_SESSION_TYPE="x11"
         SDL_VIDEODRIVER="x11"
         I3ROOT="${XDG_CONFIG_HOME:-${HOME}/.config}/i3"

         export XDG_SESSION_TYPE
         export SDL_VIDEODRIVER
         export I3ROOT

         unset ECORE_EVAS_ENGINE
         unset ELM_DISPLAY
         unset ELM_ENGINE
         unset ELM_ACCEL
         unset QT_QPA_PLATFORM
         unset QT_WAYLAND_FORCE_DPI
         unset QT_WAYLAND_DISABLE_WINDOWDECORATION
         unset MOZ_ENABLE_WAYLAND
     }
     _select_x11_manager() {
         echo "Window managers:"
         ls "/usr/share/xsessions"
         read x11wm && echo "${x11wm}" > "${HOME}/.xinitrc" && unset x11wm
     }

     if [ "$(tty)" = "/dev/tty1" ]; then
         if builtin command -v sway 2>&1 > /dev/null; then
             if sway --validate; then
                 _exports_for_sway
                 exec dbus-launch --sh-syntax --exit-with-session sway
             else
                 echo "Error while validating sway configuration"
             fi
         else
             _exports_for_x11
             _select_x11_manager
             exec startx
         fi
     elif [ "$(tty)" = "/dev/tty2" ]; then
         _exports_for_x11
         _select_x11_manager
         exec startx
     elif [ "$TERM" = "linux" ]; then
         printf "\e]P0000000" #black
         printf "\e]P83f3f3f" #darkgrey
         printf "\e]P19f3f3f" #darkred
         printf "\e]P9ff9f9f" #red
         printf "\e]P23f9f3f" #darkgreen
         printf "\e]PAbfefbf" #green
         printf "\e]P3bf9f3f" #brown
         printf "\e]PB9fff9f" #yellow
         printf "\e]P45f5f9f" #darkblue
         printf "\e]PC9f9fff" #blue
         printf "\e]P59f3f9f" #darkmagenta
         printf "\e]PDff9fff" #magenta
         printf "\e]P63f9f9f" #darkcyan
         printf "\e]PE9fffff" #cyan
         printf "\e]P7afafaf" #lightgrey
         printf "\e]PFffffff" #white
         clear #for background artifacting
     fi

   #+END_SRC

* Calls
** bash
   #+BEGIN_SRC bash :tangle dotfiles/.bash_login
     # netcheck source=.local/share/pspman/src/runcom/ui
     if [ -f "${RUNCOMDIR:-${HOME}/.runcom}"/ui ]; then
         . "${RUNCOMDIR:-${HOME}/.runcom}"/ui
     fi
   #+END_SRC

** zsh
   #+BEGIN_SRC bash :tangle dotfiles/.zlogin
     # netcheck source=.local/share/pspman/src/runcom/ui
     if [ -f "${RUNCOMDIR:-${HOME}/.runcom}"/ui ]; then
         . "${RUNCOMDIR:-${HOME}/.runcom}"/ui
     fi
   #+END_SRC
