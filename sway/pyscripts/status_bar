#!/usr/bin/env python3
# -*- coding: utf-8; mode: python -*-
'''
sway bar output
'''

from datetime import datetime
from warnings import filterwarnings
from time import sleep
from sys import exit as sysexit
from os import uname
from subprocess import Popen
from argparse import ArgumentParser, ArgumentDefaultsHelpFormatter

try:
    from psutil import (virtual_memory, cpu_percent, sensors_battery,
                        sensors_temperatures, net_if_addrs, net_io_counters)
except ModuleNotFoundError:
    while True:
        print("Install pyutils; Falling back to basic:",
              datetime.now().strftime("%Y-%m-%d %H:%M:%S"), flush=True)
        sleep(1)
    sysexit(5)


def parse_cli() -> tuple:
    '''Parse CLI to receive update loop period'''
    parser = ArgumentParser(formatter_class=ArgumentDefaultsHelpFormatter)
    parser.add_argument("period", type=int, default=1, nargs='?',
                        help="period between successive updates in seconds")
    parser.add_argument("-s", "--stats", type=int, default=1,
                        help="multple of 'period' to update other stats")
    args = parser.parse_args()
    return args.period, args.stats


class BarSeg():
    '''Segment object of the SBar'''
    def __init__(self, **kwargs) -> None:
        '''
        symbol: displayed on bar
        magnitude: the main thing
        units: suffixed to magnitude
        mem: initial (placeholder) memory to be added to buffer
        ml_tag: pango_tag to wrap around magnitude
        method: function that accepts a memory object returns
                (symbol, Magnitude, mem, ?Visible)

        Update Method Wrapper
        '''
        self.symbol = None
        self.method = None
        self.units = None
        self.vis = None
        self.mem = None
        self.ml_tag = None
        self.magnitude = None
        for key in ['magnitude', 'symbol', 'method',
                    'units', 'vis', 'mem', 'ml_tag']:
            setattr(self, key, kwargs.get(key, ''))
        self.method = self.method or (lambda: (None, None, None, True))
        if self.vis == '':
            self.vis = True
        if self.ml_tag == '':
            self.ml_tag = ['', '']

    def update(self, method=None) -> None:
        '''
        method: function that updates the segment
        kwargs: a dict object returned by method, that may contain:
        symbol: to update
        magnitude: to update
        mem: to update
        magnitude: to update
        ml_tag: pango tag to decorate

        Update magnitude and symbol
        '''
        if method:
            kwargs = method(self.mem)
        else:
            kwargs = self.method(self.mem)
        self.symbol = kwargs.get('symbol', self.symbol)
        self.magnitude = kwargs.get('magnitude', self.magnitude)
        self.vis = kwargs.get('vis', True)
        self.mem = kwargs.get('mem', self.mem)
        self.ml_tag = kwargs.get('ml_tag', self.ml_tag)


class SBar():
    '''Sway wrapper class'''
    def __init__(self):
        '''Initiate an empty bar'''
        self.bar_str = ''
        self.bar_segs = []
        self.quick_segs = []
        self.slow_segs = []
        self.static_segs = []

    def add_segs(self, interval: int = 1, position: int = None, **kwargs):
        '''
        interval: Interval of update: 0: Begin, 1: frequent, 2: intermittent
        position: Position of segment from edge
        **kwargs: will be passed to BarSeg

        Add segment to bar
        '''
        new_seg = BarSeg(**kwargs)
        self.bar_segs.insert(position, new_seg)

        if interval == 1:
            self.quick_segs.append(new_seg)
        elif interval == 2:
            self.slow_segs.append(new_seg)
        else:
            self.static_segs.append(new_seg)
        return new_seg

    def _slow_tick(self) -> None:
        '''fast updating segments'''
        for seg in self.slow_segs:
            seg.update()

    def _quick_tick(self) -> None:
        '''slow updating widgets'''
        for seg in self.quick_segs:
            seg.update()

    def _static_vals(self) -> None:
        '''static widgets'''
        for seg in self.static_segs:
            seg.update()

    def _update_str(self, sep='|') -> None:
        '''Update bar string'''
        self.bar_str = f' {sep} '.join(
            reversed(
                [f'\
{seg.symbol} \
{seg.ml_tag[0]}\
{seg.magnitude}\
{seg.ml_tag[1]}\
{seg.units}'
                 for seg in filter(lambda x: x.vis, self.bar_segs)]
            )
        )

    def loop(self, period: int = 1, multi: int = 1) -> None:
        '''
        period: Period between two updates in seconds.

        Loop update
        float is discouraged
        '''
        self._static_vals()
        long_per = 0
        while True:
            self._quick_tick()
            if not long_per:
                self._slow_tick()
            self._update_str(" ")
            print(self.bar_str, flush=True)
            long_per = (long_per + period) % multi
            sleep(period)


class Definitions():
    '''Compilation of all defined sensors'''
    def __init__(self) -> None:
        '''Object container for all defined bar segments'''
        self.emojis = {
            "cpu":       chr(0x1f9e0),
            "bat_100":   chr(0xf240),
            "bat_75":    chr(0xf240),
            "bat_50":    chr(0xf242),
            "bat_25":    chr(0xf243),
            "bat_0":     chr(0xf244),
            "ram":       chr(0xf233),
            "clock":     chr(0x23f0),
            "tux":       chr(0x1f427),
            "wifi":       chr(0x21f5),
            "fire":      chr(0x1f525),
            "temp_100":  chr(0xf2c7),
            "temp_75":   chr(0xf2c8),
            "temp_50":   chr(0xf2c9),
            "temp_25":   chr(0xf2ca),
            "temp_0":    chr(0xf2cb),
            "net":      chr(0x1f4f6),
        }

    @staticmethod
    def _bat_act(conn, fill, mem) -> None:
        '''Emergency Actions'''
        if conn:
            if fill > 99 and mem < 5:
                mem += 1
                # Send only 5 notifications
                Popen(['notify-send', 'Battery_charged'])
        else:
            mem = 0
            if fill < 20:
                Popen(['notify-send', 'Battery Too Low'])
            elif fill < 10:
                Popen(['notify-send', 'Battery Too Low Suspending Session...'])
            elif fill < 5:
                Popen(['systemctl', 'suspend'])
        return mem

    def battery(self, mem=None) -> tuple:
        '''Create Battery summary string'''
        sym_ml = ['', '']
        bat_probe = sensors_battery()
        if not bat_probe:
            return {'symbol': self.emojis['bat_0'], 'vis': False}
        bat_fill = bat_probe.percent
        bat_conn = bat_probe.power_plugged
        if bat_conn:
            sym_ml = ['<span foreground="#77AAFFFF">', '</span>']
        # Action
        mem = self._bat_act(conn=bat_conn, fill=bat_fill, mem=mem)
        # returns
        ml_tag = ['', '']
        if bat_fill >= 100:
            sym, val = self.emojis['bat_100'], "100"
            ml_tag = ['<span foreground="#77AAFFFF">', '</span>']
        elif bat_fill > 75:
            sym, val = self.emojis['bat_75'], f"{bat_fill:.2f}"
            ml_tag = ['<span foreground="#FFFF55FF">', '</span>']
        elif bat_fill > 50:
            sym, val = self.emojis['bat_50'], f"{bat_fill:.2f}"
            ml_tag = ['<span foreground="#FF5555FF">', '</span>']
        elif bat_fill > 25:
            sym, val = self.emojis['bat_25'], f"{bat_fill:.2f}"
            ml_tag = ['<span foreground="#FF3333FF">', '</span>']
        else:
            sym, val = self.emojis['bat_0'], f"{bat_fill:.2f}"
        sym = sym_ml[0] + sym + sym_ml[1]
        return {'symbol': sym, 'magnitude': val, 'mem': mem, 'ml_tag': ml_tag}

    @staticmethod
    def ram_use(_=None) -> tuple:
        '''Create RAM summary string'''
        ram_fill = virtual_memory().percent
        ml_tag = ['', '']
        if ram_fill > 80:
            ml_tag = ['<span foreground="#FF5533FF">', '</span>']
        elif ram_fill > 60:
            ml_tag = ['<span foreground="#FFFF33FF">', '</span>']
        return {'magnitude': f"{ram_fill:.0f}", 'ml_tag': ml_tag}

    @staticmethod
    def time(_=None) -> tuple:
        '''create Time summary string'''
        return {'magnitude': datetime.now().strftime("%Y-%m-%d %H:%M:%S")}

    @staticmethod
    def cpu(_=None) -> tuple:
        '''Create CPU summary string'''
        return {'magnitude': f"{cpu_percent():.2f}"}

    def heat(self, _=None) -> tuple:
        '''Create Temperature summary string'''
        ml_tag = ['', '']
        heat = sensors_temperatures()['coretemp'][0].current
        if heat > 80:
            sym, val = self.emojis['fire'], f"{heat:.0f}"
            ml_tag = ['<span foreground="#FF3333FF">', '</span>']
        elif heat > 70:
            sym, val = self.emojis['temp_100'], f"{heat:.0f}"
            ml_tag = ['<span foreground="#FF3333FF">', '</span>']
        elif heat > 60:
            sym, val = self.emojis['temp_75'], f"{heat:.0f}"
            ml_tag = ['<span foreground="#FFFF33FF">', '</span>']
        elif heat > 50:
            sym, val = self.emojis['temp_50'], f"{heat:.0f}"
        elif heat > 40:
            sym, val = self.emojis['temp_25'], f"{heat:.0f}"
        else:
            sym, val = self.emojis['temp_0'], f"{heat:.0f}"
        return {'symbol': sym, 'magnitude': val, 'ml_tag': ml_tag}

    @staticmethod
    def ip_addr(_=None) -> tuple:
        '''Create IP ADDRESS string'''
        for ip_key in net_if_addrs().keys():
            if "wl" in ip_key:
                for sub_dev in list(net_if_addrs()[ip_key]):
                    if sub_dev.netmask and sub_dev.broadcast:
                        addr = sub_dev.address
                        if addr.split(".")[:2] == ["192", "168"]:
                            return {'magnitude': ".".join(addr.split(".")[2:])}
                        return {'magnitude': sub_dev.address}
        return {'vis': False}

    @staticmethod
    def uname(_=None) -> tuple:
        '''Create Linux release string'''
        return {'magnitude': f"{uname().release.split('.')[-2]}"}

    @staticmethod
    def netspeed(mem=None) -> tuple:
        '''Total internet Speed'''
        net_stats = net_io_counters()
        if not net_stats:
            return {'mem': mem}
        down_l = net_stats.bytes_recv / 1048576
        up_l = net_stats.bytes_sent / 1048576
        diff = (down_l - mem[1])/mem[0], (up_l - mem[2])/mem[0]
        return {'magnitude': f"{diff[0]:.2f}/{diff[1]:.2f}",
                'mem': [mem[0], down_l, up_l]}


def main():
    '''Main Routine'''
    period, multi = parse_cli()
    senses = Definitions()
    topbar = SBar()
    topbar.add_segs(symbol=senses.emojis['clock'],
                    position=0, method=senses.time, interval=1)
    topbar.add_segs(symbol=senses.emojis['bat_0'], units="%", mem=0,
                    position=1, method=senses.battery, interval=2)
    topbar.add_segs(symbol=senses.emojis['cpu'], units="%",
                    position=2, method=senses.cpu, interval=1)
    topbar.add_segs(symbol=senses.emojis['fire'], units=chr(0x2103),
                    position=3, method=senses.heat, interval=2)
    topbar.add_segs(symbol=senses.emojis['ram'], units="%",
                    position=4, method=senses.ram_use, interval=1)
    topbar.add_segs(symbol=senses.emojis['net'],
                    position=5, method=senses.ip_addr, interval=0)
    topbar.add_segs(symbol=senses.emojis['tux'],
                    position=7, method=senses.uname, interval=0)
    topbar.add_segs(symbol=senses.emojis['wifi']+chr(0x25BC),
                    units=chr(0x25B2) + "MB/s",
                    mem=[period * multi, 0, 0],
                    position=6, method=senses.netspeed, interval=2)
    topbar.loop(period=period, multi=multi)
    sysexit(0)


if __name__ == "__main__":
    filterwarnings('ignore')
    main()
