# shellcheck shell=bash
# -*- coding:utf-8; mode:shell-script; -*-
#
# Copyright 2020 Pradyumna Paranjape
#
# This file is part of Prady_runcom.
#
# Prady_runcom is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Prady_runcom is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with Prady_runcom.  If not, see <https://www.gnu.org/licenses/>.
#

# shellcheck source=.local/share/pspman/src/runcom/complete.bash
if [ -f "${RUNCOMDIR}"/complete.bash ]; then
    # shellcheck source=.local/share/pspman/src/runcom/complete.bash
    . "${RUNCOMDIR}"/complete.bash
fi

export PY_ARG_COMPL_SCRIPTS=( "frac-time" "ppsid" "ppsi pspbar")

if command -v nvim >/dev/null 2>/dev/null; then
    MANPAGER="nvim -c 'set ft=man' -"
fi
export MANPAGER

export BEMENU_OPTS='--fn firacode 14 '

function python_ver() {
    python --version |cut -d "." -f1,2 |sed 's/ //' |sed 's/P/p/'
}

function deactivate() {
    true
}

# shellcheck shell=sh
function to_venv () {
    cwd="$(realpath $PWD)"
    testdir="${cwd}"
    until mountpoint "${testdir}"; do
        if [ -d "${testdir}"/.venv ] || [ -L "${testdir}"/.venv ]; then
            # .venv found
            . "${testdir}/.venv/bin/activate"
            return
        fi
        testdir="$(dirname "${testdir}")"
    done
}

function git_status() {
    local modified=0
    local cached=0
    local untracked=0

    while read -r line; do
        if [ "$line" = '_?_?_' ]; then
            untracked=1
            continue
        fi

        if [[ "$line" =~ ^_[^[:space:]]_.?_ ]]; then
            cached=1
        fi

        if [[ "$line" =~ ^_._[^[:space:]]_ ]]; then
            modified=1
        fi
    done < <(git status --short | cut -b -2 | sed -e 's/\(.\)\(.*\)/_\1_\2_/')

    stat_str=''
    if [ $modified -ne 0 ]; then
        stat_str="${stat_str}\033[0;31m\ue728"
    fi

    if [ $cached -ne 0 ]; then
        stat_str="${stat_str}\033[0;32m\ue729"
    fi

    if [ $untracked -ne 0 ]; then
        stat_str="${stat_str}\033[0;31m\uf476"
    fi

    if [ -n "$(git stash list)" ]; then
        stat_str="${stat_str}\e[0;36m\uf48e"
    fi
    if [[ -n "${stat_str}" ]]; then
        echo -en "${stat_str}\e[m"
    fi
}

function git_branch() {
    local branch
    branch="$(git branch 2>/dev/null | grep '^\*' | sed -e "s/^* //")"
    if [[ -n "$branch" ]]; then
        if [[ "${branch}" =~ ^feat- ]]; then
            echo -ne "\033[0;32m"
        elif [[ "${branch}" =~ ^bug- ]]; then
            echo -ne "\033[0;31m"
        elif [[ "${branch}" =~ ^atc- ]]; then
            echo -ne "\e[0;36m"
        elif [[ "${branch}" =~ ^tmp ]]; then
            echo -ne "\e[0;35m"
        elif [[ "${branch}" = "(detached from hde/master)" ]]; then
            echo -ne "\e[0;33m"
        elif [[ "${branch}" == "master" ]]; then
            return
        else
            echo -ne "\e[0;35m"
        fi
        echo -ne "${branch}\ue725"
        echo -ne "\e[m"
    fi
}

function git_hash() {
    git log --pretty=format:'%h' -n 1
}

function git_ps() {
    if ! git status --ignore-submodules &>/dev/null; then
        return
    else
        echo -ne " $(git_branch)$(git_hash)$(git_status) "
    fi
}

last_exit_color () {
    err="$1"
    if [ "$err"  = "0" ]; then
        # no error
        printf "\e[0;32m"
    elif [ "$err"  = "1" ]; then
        # general error
        printf "\e[0;33m"
    elif [ "$err"  = "2" ]; then
        # misuse of shell builtins
        printf "\e[0;31m"
    elif [ "$err" -gt "63" ] && [ "$err" -lt "84" ]; then
        # syserror.h
        printf "\e[0;91m"
    elif [ "$err"  = "126" ]; then
        # cannot execute
        printf "\e[0;37m"
    elif [ "$err"  = "127" ]; then
        # command not found
        printf "\e[0;30m"
    elif [ "$err" -gt "127" ] && [ "$err" -lt "191" ]; then
        # Fatal error
        printf "\e[0;41m"
    elif [ "$err"  = "255" ]; then
        # exit status limit
        printf "\e[0;31m"
    else
        printf "\e[0;31m"
    fi
}

function mathcalc() {
    echo "$*"| bc -lq
}

function dec2hex() {
    echo "hex:"
    echo "obase=16; $*"| bc
    echo "dec:"
    echo "ibase=16; $*"| bc
}

function pdfcompile() {
    pdflatex "$1"
    for ext in toc log aux; do
        delfile="${1/\.tex/\.$ext}"
        [[ -f "$delfile" ]] && rm "$delfile"
    done
    evince "${1/\.tex/\.pdf}"
}

function org2export() {
    # Usage: org2oth [-f] <infile> <othtype>
    proceed=
    while test $# -gt 1; do
        case "$1" in
            -f|--force)
                proceed=true
                shift 1
                ;;
            *)
                infile="${1}"
                shift 1
                ;;
        esac
    done
    if [ "${1}" = "pdf" ]; then
        target="latex"
    else
        target="${1}"
    fi
    tarext="${1}"
    if [ "$infile" = *.org ]; then
        proceed=true
    else
        echo "Input file should be an org file"
    fi
    if [ -n "$proceed" ]; then
        pandoc -f org -t "${target}" -o "${infile/.org/}.${tarext}" "$infile"
    fi
    proceed=
    target=
    infile=
}

function org2doc () {
    org2export "$@" "docx"
}

function org2pdf () {
    org2export "$@" "pdf"
}

function doc2org() {
    if [ "$1" == *.docx ]; then
        pandoc -f docx -t org -o  "${1/%docx/org}" "$1"
    else
        echo "Input file must be a docx file"
    fi
}

function mount_home_cloud() {
    # shellcheck disable=SC2154
    if [ -z "${home_cloud}" ] || [ -z "${cloud_user}" ]; then
        echo "variables \$home_cloud OR \$cloud_user haven't been defined"
        return
    fi
    # netcheck source=./netcheck.sh
    IFS=$'\t' read -r IP_ADDR AP_ADDR netstate <<< "$("${RUNCOMDIR}"/netcheck.sh)"
    # IFS=$'\t' read -r -a netcodes <<< "$("${RUNCOMDIR}"/netcheck.sh)"
    if [ $(( netstate % 4 )) -eq 2 ]; then
        clouddir=( "/media/data" "/home/${cloud_user}" )
        srv_mnt_dir="${HOME}/${home_cloud}"
        if [ $(mount | grep -c "${srv_mnt_dir}") \
                 -lt "${#clouddir[@]}" ]; then
            # not mounted
            for pathloc in "${clouddir[@]}"; do
                mntpath="${srv_mnt_dir}${pathloc}"
                mkdir -p "$mntpath"
                sshfs -o "reconnect,ServerAliveInterval=15,ServerAliveCountMax=3" "${cloud_user}@${home_cloud}:${pathloc}" "$mntpath"
            done
        fi
    fi
}

gui () {
    usage="usage: $0 [-h|--help] CMD\n"
    cmd_help="Launch CMD, switch to it, and exit the parent terminal\n\n"
    cmd_help="${cmd_help}Optional arguments:\n"
    cmd_help="${cmd_help}-h|--help\tdisplay this help and exit\n"
    command=
    call=

    while [ $# -gt 0 ]; do
        case "$1" in
            --help|-h)
                printf "%s""${usage}"
                printf "%s""${cmd_help}"
                shift 1
                unset command
                unset cmd_help
                unset usage
                unset call
                return 0
                ;;
            --)
                # end of gui arguments
                command="${command} $*"
                break
                ;;
            *)
                command="${1}"
                shift 1
                ;;
        esac
    done

    call="$(echo "${command}" | cut -d " " -f 1)"
    if [ -n "${call}" ]; then
        if command -v "${call}" > /dev/null 2>&1; then
            unset cmd_help
            unset usage
            unset call
            nohup ${command} >/dev/null 0<&- 2>&1 & exit 0
        else
            echo "${call} not found..."
            unset command
            unset cmd_help
            unset usage
            unset call
            return 127
        fi
    else
        printf "%s""${usage}"
        unset command
        unset cmd_help
        unset usage
        unset call
        return 1
    fi

}

deconvolute() {
    if [ ! -f "$1" ]; then
        echo "$1: no such file";
    else
        case "$1" in
            *.tar.bz2) tar -xjf "$1" ;;
            *.tbz2) tar -xjf "$1" ;;
            *.tar.gz) tar -x --use-compress-program=pigz -f "$1" ;;
            *.tgz) tar -x --use-compress-program=pigz -f "$1" ;;
            *.gz) pigz "$1" ;;
            *.rar) unrar -x "$1" ;;
            *.tar) tar -xf "$1" ;;
            *.zip) unzip "$1" ;;
            *.tar.xz) tar -xf "$1" ;;
            *) echo "Cannot extract $1, provide explicit command";;
        esac
    fi
}

# Inspired by lukesmith.xyz
lfcd () {
    if ! command -v 'lf' > /dev/null 2>/dev/null; then
        return
    fi
    tmp="$(mktemp)"
    lf -last-dir-path="$tmp" "$@"
    if [ -f "$tmp" ]; then
        dir="$(cat "$tmp")"
        rm -f "$tmp" >/dev/null
        [ -d "$dir" ] && [ "$dir" != "$(pwd)" ] && cd "$dir"
    fi
}
fzfcd () {
    cd "$(dirname "$(fzf)")"
}

alias du='du -hc';
alias df='df -h';
alias duall="du -hc |\grep '^[3-9]\{3\}M\|^[0-9]\{0,3\}\.\{0,1\}[0-9]\{0,1\}G'";

alias nload='nload -u M -U G -t 10000 -a 3600 $(ip a | grep -m 1 " UP " | cut -d " " -f 2 | cut -d ":" -f 1)'
alias nethogs='\su - -c "nethogs $(ip a |grep  "state UP" | cut -d " " -f 2 | cut -d ":" -f 1) -d 10"';
alias ping="ping -c 4 ";

alias watch="watch -n 10 --color";
alias psauxgrep="ps aux |head -1 && ps aux | grep -v 'grep' | grep -v 'rg'| grep -i";

alias qqqq="exit";

if command -v 'bat' >/dev/null 2>/dev/null; then
    alias cat="bat --color=auto";
fi

for sc in "ack" "pt" "ag" "rg"; do
    if command -v "${sc%% *}" &>/dev/null; then
        # shellcheck disable=SC2139
        alias grep="${sc} --color=auto";
    fi
done

if command -v "exa" >>/dev/null; then
    alias ls="exa -Fh --color=auto";
    alias la='exa -a --color=auto';
    alias ll='exa -lr -s size';
    alias lla='exa -a';
    alias l.='exa -a --color=auto |grep "^\."';
    alias sl="ls";
fi

if command -v nvim >>/dev/null; then
    alias ex="nvim"; ## always open vim in normal mode
    alias vim="nvim"; ## always use neo
    export MANPAGER="nvim -c 'set ft=man' -"
fi

if command -v podman >>/dev/null; then
    alias docker="podman";  # Podman is drop-in replacement for docker
    alias docker-compose="podman-compose";  # Podman is drop-in replacement for docker
fi

# shellcheck source=./netcheck.sh
IFS=$'\t' read -r IP_ADDR AP_ADDR netstate <<< "$("${RUNCOMDIR}"/netcheck.sh)"
# IFS=$'\t' read -r -a netcodes <<< "$("${RUNCOMDIR}"/netcheck.sh)"
export IP_ADDR
export AP_ADDR
if [ "${netstate}" -gt 7 ]; then
    printf "\e[1;34mInternet (GOOGLE) Connected\e[m\n"
    printf "\033[0;32m$IP_ADDR \e[m is current wireless ip address\n"
else
    printf "\e[1;31mInternet (GOOGLE) Not reachable\e[m\n"
    if [ $(( netstate % 8 )) -gt 3 ]; then  # Intranet is connected
        printf "\033[0;31mInternet Down\e[m\n"
        case $(( netstate % 4 )) in
            2) printf "Home network connected,\n"
               ;;
            1) printf "CCMB network connected,\n"
               # shellcheck source=./proxy_send.py
               if [ -f "${RUNCOMDIR}/proxy_send.py" ]; then
                   # shellcheck source=./proxy_send.py
                   "${RUNCOMDIR}/proxy_send.py" \
                       && printf "\e[0;33mPROXY AUTH SENT\e[m\n";
               fi
               ;;
            *) printf "HOTSPOT connected\n"
               ;;
        esac
    else
        printf "\e[1;33mNetwork connection Disconnected\e[m\n"
    fi
fi
