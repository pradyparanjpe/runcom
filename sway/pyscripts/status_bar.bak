#!/usr/bin/env python3
# -*- coding: utf-8; mode: python -*-
'''
sway bar output
'''

from datetime import datetime
from warnings import filterwarnings
from time import sleep
from sys import exit as sysexit
from os import uname
from subprocess import Popen
from argparse import ArgumentParser, ArgumentDefaultsHelpFormatter

try:
    from psutil import (virtual_memory, cpu_percent, sensors_battery,
                        sensors_temperatures, net_if_addrs)
except ModuleNotFoundError:
    while True:
        print("Install pyutils; Falling back to basic:",
              datetime.now().strftime("%Y-%m-%d %H:%M:%S"), flush=True)
        sleep(1)
    sysexit(5)


def parse_cli() -> tuple:
    '''Parse CLI to receive update loop period'''
    parser = ArgumentParser(formatter_class=ArgumentDefaultsHelpFormatter)
    parser.add_argument("period", type=int, default=1, nargs='?',
                        help="period between successive updates in seconds")
    parser.add_argument("-s", "--stats", type=int, default=1,
                        help="multple of 'period' to update other stats")
    args = parser.parse_args()
    return args.period, args.stats


class BarSeg():
    '''Segment object of the SBar'''
    def __init__(self, symbol: str = None, method=None,
                 units: str = None, mem=None) -> None:
        '''
        affix: (symbol, units)
        symbol: displayed on bar
        value: the main thing
        units: suffixed to value
        postion: from anchor end
        method: function that accepts a memory object returns
                (symbol, Value, mem, ?Visible)

        Update Method Wrapper
        '''
        self.symbol: str = symbol
        self.value: str = ''
        self.units: str = units or ''
        self.method = method or (lambda: (None, None, None, True))
        self.vis: bool = True
        self.mem = mem

    def update(self, method=None) -> None:
        '''
        method: function that updates the segment
        symbol: Should be returned by method
        value: should be returned by method

        Update value and symbol
        '''
        if method:
            symbol, value, mem, vis = method(mem=self.mem)
        else:
            symbol, value, mem, vis = self.method(mem=self.mem)
        self.symbol = symbol or self.symbol
        self.value = value or self.value
        self.vis = vis
        self.mem = mem


class SBar():
    '''Sway wrapper class'''
    def __init__(self):
        '''Initiate an empty bar'''
        self.bar_str = ''
        self.bar_segs = []
        self.quick_segs = []
        self.slow_segs = []
        self.static_segs = []

    def add_segs(self, **kwargs):
        '''
        symbol: prefix to be displayed for the sensor
        units: suffix to be added to the sensor
        position: integer position from edge
        interval: 0: No Update, 1: quick update, 2: slow update
        method: method to run to update program
        mem: initiation value of memory register

        Add segment to bar
        '''
        new_seg = BarSeg(
            symbol=kwargs.get('symbol', None),
            method=kwargs.get('method', None),
            units=kwargs.get('units', None),
            mem=kwargs.get('mem', None),
        )
        self.bar_segs.insert(kwargs['position'], new_seg)

        if 'interval' not in kwargs:
            self.quick_segs.append(new_seg)
        elif kwargs['interval'] == 1:
            self.quick_segs.append(new_seg)
        elif kwargs['interval'] == 2:
            self.slow_segs.append(new_seg)
        else:
            self.static_segs.append(new_seg)
        return new_seg

    def _slow_tick(self) -> None:
        '''fast updating segments'''
        for seg in self.slow_segs:
            seg.update()

    def _quick_tick(self) -> None:
        '''slow updating widgets'''
        for seg in self.quick_segs:
            seg.update()

    def _static_vals(self) -> None:
        '''static widgets'''
        for seg in self.static_segs:
            seg.update()

    def _update_str(self) -> None:
        '''Update bar string'''
        self.bar_str = ' | '.join(reversed(
            [f'{seg.symbol} {seg.value} {seg.units}' for seg in self.bar_segs]
        ))

    def loop(self, period: int = 1, multi: int = 1) -> str:
        '''
        period: Period between two updates in seconds.

        Loop update
        float is discouraged
        '''
        self._static_vals()
        long_per = 0
        while True:
            self._quick_tick()
            if not long_per:
                self._slow_tick()
            self._update_str()
            print(self.bar_str, flush=True)
            long_per = (long_per + period) % multi
            sleep(period)


class Definitions():
    '''Compilation of all defined sensors'''
    def __init__(self) -> None:
        '''Object container for all defined bar segments'''
        self.emojis = {
            "cpu":       chr(0x1F9E0),
            "bat_100":   chr(0xf240),
            "bat_75":    chr(0xf241),
            "bat_50":    chr(0xf242),
            "bat_25":    chr(0xf243),
            "bat_0":     chr(0xf244),
            "ram":       chr(0xf233),
            "clock":     chr(0x23f0),
            "tux":       chr(0x1f427),
            "net":       chr(0x21f5),
            "fire":      chr(0x1F525),
            "temp_100":  chr(0xf2c7),
            "temp_75":   chr(0xf2c8),
            "temp_50":   chr(0xf2c9),
            "temp_25":   chr(0xf2ca),
            "temp_0":    chr(0xf2cb),
        }

    @staticmethod
    def _bat_act(conn, fill, mem) -> None:
        '''Emergency Actions'''
        if conn:
            if fill > 99 and mem < 5:
                mem += 1
                # Send only 5 notifications
                Popen(['notify-send', 'Battery_charged'])
        else:
            mem = 0
            if fill < 20:
                Popen(['notify-send', 'Battery Too Low'])
            elif fill < 10:
                Popen(['notify-send', 'Battery Too Low Suspending Session...'])
            elif fill < 5:
                Popen(['systemctl', 'suspend'])
        return mem

    def battery(self, mem=None) -> tuple:
        '''Create Battery summary string'''
        bat_probe = sensors_battery()
        if not bat_probe:
            return self.emojis['bat_0'], None, mem, False
        bat_fill = bat_probe.percent
        bat_conn = bat_probe.power_plugged

        # Action
        mem = self._bat_act(conn=bat_conn, fill=bat_fill, mem=mem)
        # returns
        if bat_fill >= 100:
            sym, val = self.emojis['bat_100'], "100"
        elif bat_fill > 75:
            sym, val = self.emojis['bat_75'], f"{bat_fill:.2f}"
        elif bat_fill > 50:
            sym, val = self.emojis['bat_50'], f"{bat_fill:.2f}"
        elif bat_fill > 25:
            sym, val = self.emojis['bat_25'], f"{bat_fill:.2f}"
        else:
            sym, val = self.emojis['bat_0'], f"{bat_fill:.2f}"
        return sym, val, mem, True

    @staticmethod
    def memory(mem=None) -> tuple:
        '''Create Memory summary string'''
        return None, f"{virtual_memory().percent:.0f}", mem, True

    @staticmethod
    def time(mem=None) -> str:
        '''create Time summary string'''
        return None, datetime.now().strftime("%Y-%m-%d %H:%M:%S"), mem, True

    @staticmethod
    def cpu(mem=None) -> str:
        '''Create CPU summary string'''
        return None, f"{cpu_percent():.2f}", mem, True

    def heat(self, mem=None) -> str:
        '''Create Temperature summary string'''
        heat = sensors_temperatures()['coretemp'][0].current
        if heat > 80:
            return self.emojis['fire'], f"{heat:.0f}", mem, True
        if heat > 70:
            return self.emojis['temp_100'], f"{heat:.0f}", mem, True
        if heat > 60:
            return self.emojis['temp_75'], f"{heat:.0f}", mem, True
        if heat > 50:
            return self.emojis['temp_50'], f"{heat:.0f}", mem, True
        if heat > 40:
            return self.emojis['temp_25'], f"{heat:.0f}", mem, True
        return self.emojis['temp_0'], f"{heat:.0f}", mem, True

    @staticmethod
    def ip_addr(mem=None) -> str:
        '''Create IP ADDRESS string'''
        for ip_key in net_if_addrs().keys():
            if "wl" in ip_key:
                for sub_dev in list(net_if_addrs()[ip_key]):
                    if sub_dev.netmask and sub_dev.broadcast:
                        return None, sub_dev.address, mem, True
        return None, None, mem, True

    @staticmethod
    def uname(mem=None) -> str:
        '''Create Linux release string'''
        return None, f"{uname().release.split('.')[-2]}", mem, True


def main():
    '''Main Routine'''
    period, multi = parse_cli()
    senses = Definitions()
    topbar = SBar()
    topbar.add_segs(symbol=senses.emojis['clock'],
                    position=0, method=senses.time, interval=1)
    topbar.add_segs(symbol=senses.emojis['bat_0'], units="%", mem=0,
                    position=1, method=senses.battery, interval=2)
    topbar.add_segs(symbol=senses.emojis['cpu'], units="%",
                    position=2, method=senses.cpu, interval=1)
    topbar.add_segs(symbol=senses.emojis['fire'], units=chr(0x2103),
                    position=3, method=senses.heat, interval=2)
    topbar.add_segs(symbol=senses.emojis['ram'], units="%",
                    position=4, method=senses.memory, interval=1)
    topbar.add_segs(symbol=senses.emojis['net'],
                    position=5, method=senses.ip_addr, interval=0)
    topbar.add_segs(symbol=senses.emojis['tux'],
                    position=5, method=senses.uname, interval=0)
    topbar.loop(period=period, multi=multi)
    sysexit(0)


if __name__ == "__main__":
    filterwarnings('ignore')
    main()
